# 第四章 处理器体系结构

一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构（ISA）。

ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们如何编码的；而处理器设计者必须建造出指令这些指令的处理器。



## 4.1 Y86-64 指令集体系结构

​	定义一个指令集体系结构包括定义**各种状态单元**、**指令集**和它们的**编码**、一组**编程规范**和**异常事件处理。**



### 4.1.1 程序员可见的状态

![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210630133559520.png)	

### 4.1.2 Y86-64 指令

![image-20210630133856537](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210630133856537.png)	

![image-20210630134325532](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210630134325532.png)	

### 4.1.3 指令编码

字节级编码中第一个字节表明指令的类型。高四位是代码部分，低四位是功能部分。

![image-20210630140007098](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210630140007098.png)	

如图4-4所示，15个程序寄存器中每个都有一个相对应的范围在0到0xE之间的寄存器标识符。Y86-64中的寄存器编号跟X86-64的相同。程序寄存器存在CPU中的一个寄存器文件中，这个**寄存器文件就是一个小的、以寄存器id为地址的随即访问存储器**。在指令编码以及我们的硬件设计当中，当需要指明不应该访问任何寄存器时，就用ID值0xF来表示。

寄存器指示符指定一个或两个寄存器。

分支指令和调用指令选择用绝对地址。

所有整数采用小端法编码。

16字节来表示指令级字节编码。

```
rmmovq %rsp, 0x123456789abcd(%rdx)
```

图4-2所示，rmmovq的第一个字节为40

图4-4所示，源、目的寄存器的寄存器指示符字节为42

偏移量放在8字节的常数字中。首先将常数字扩展为8字节,然后按字节反序，cd ab 89 67 45 23 01 00

连接在一起：

```
4042cdab896745230100
```

 指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。Y86-64就具有这个性质，因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节我们就可以决定所有其他附加字节的长度和含义。这个性质保证了处理器可以无二义性地执行目标代码程序。即使代码在程序的其他字节中，只要从字节的第一个序列开始处理，我们仍然很容易地确定指令序列。反过来说，如果不知道一段代码的**起始位置**，我们就不能准确地**确定怎样将序列划分为单独的指令**。

对于试图直接**从目标代码字节序列中抽取出机器级程序的反汇编程序**和其他一些工具来说，这就带来了问题。



### 4.1.4 Y86-64 异常

