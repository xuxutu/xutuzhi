# 第四章 处理器体系结构

一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构（ISA）。

ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们如何编码的；而处理器设计者必须建造出指令这些指令的处理器。



## 4.1 Y86-64 指令集体系结构

​	定义一个指令集体系结构包括定义**各种状态单元**、**指令集**和它们的**编码**、一组**编程规范**和**异常事件处理。**



### 4.1.1 程序员可见的状态

![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210630133559520.png)	

### 4.1.2 Y86-64 指令

![image-20210630133856537](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210630133856537.png)	

![image-20210630134325532](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210630134325532.png)	

### 4.1.3 指令编码

字节级编码中第一个字节表明指令的类型。高四位是代码部分，低四位是功能部分。

![image-20210630140007098](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210630140007098.png)	

如图4-4所示，15个程序寄存器中每个都有一个相对应的范围在0到0xE之间的寄存器标识符。Y86-64中的寄存器编号跟X86-64的相同。程序寄存器存在CPU中的一个寄存器文件中，这个**寄存器文件就是一个小的、以寄存器id为地址的随即访问存储器**。在指令编码以及我们的硬件设计当中，当需要指明不应该访问任何寄存器时，就用ID值0xF来表示。

寄存器指示符指定一个或两个寄存器。

分支指令和调用指令选择用绝对地址。

所有整数采用小端法编码。

16字节来表示指令级字节编码。

```
rmmovq %rsp, 0x123456789abcd(%rdx)
```

图4-2所示，rmmovq的第一个字节为40

图4-4所示，源、目的寄存器的寄存器指示符字节为42

偏移量放在8字节的常数字中。首先将常数字扩展为8字节,然后按字节反序，cd ab 89 67 45 23 01 00

连接在一起：

```
4042cdab896745230100
```

 指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。Y86-64就具有这个性质，因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节我们就可以决定所有其他附加字节的长度和含义。这个性质保证了处理器可以无二义性地执行目标代码程序。即使代码在程序的其他字节中，只要从字节的第一个序列开始处理，我们仍然很容易地确定指令序列。反过来说，如果不知道一段代码的**起始位置**，我们就不能准确地**确定怎样将序列划分为单独的指令**。

对于试图直接**从目标代码字节序列中抽取出机器级程序的反汇编程序**和其他一些工具来说，这就带来了问题。



### 4.1.4 Y86-64 异常

![image-20210702130014331](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210702130014331.png)	

对于Y86-64，当遇到这些异常的时候，我们就简单地让处理器停止执行指令。在更完整地设计当中，处理器通常会调用一个异常处理程序，这个过程被指定用来处理遇到的某种类型的异常。就像在第八章中讲述的，异常处理程序可以被配置为不同的结果。例如，终止程序或者调用一个用户自定义的信号处理程序。

 

### 4.1.5 Y86-64 程序

![image-20210707114743321](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707114743321.png)	



以点开头的指令是**汇编器伪指令**，他们告诉汇编器调整地址，以便在那儿产生代码或**插入一些数据**。伪指令.pos 0告诉汇编器应该从地址0处产生代码。这个地址是所有Y86-64程序的起点。



### 4.1.6 一些Y86-64指令的详情

![image-20210707134429475](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707134429475.png)	



## 4.2 逻辑设计和硬件控制语言

​	在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储单元的存储位。大多数现代电路技术都是用信号线上的高电压或低电压来表示不同的位值。在当前的技术中，逻辑1是1.0伏特左右的高电压表示的，而逻辑0是用0.0伏特左右的低电压表示的。要实现一个数字系统需要三个主要的组成部分：计算对位进行**操作的函数的组合逻辑**、**存储位的存储器单元**，以及**控制存储器单元更新的时钟信号**。

 	HCL（硬件控制语言）描述不同处理器设计的控制逻辑。

 	HDL（硬件描述语言）用来描述硬件结构



### 	4.2.1 逻辑门

​	逻辑门是数字电路的基本计算单元。它们产生的输出，等于他们输入位值的某个布尔函数。逻辑门只对单个位的数进行操作。 

![image-20210707140557702](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707140557702.png)	

​    逻辑门总是活动的。一旦一个门的输入变化了，在很短的时间内，输出就会相应地变化。

​	

### 	4.2.2 组合电路和HCL布尔表达式

​	![image-20210707141539847](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707141539847.png)

​		图4-10是一个非常有用的简单组合电路的例子。他们有两个输入a和b，有唯一的输出eq，当a和b都是1，或都是0时，输出为1。用HCL写这个网的函数就是：

![image-20210707141750971](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707141750971.png)

![image-20210707142359977](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707142359977.png)	

​			图4-11给出了一个简单但很有用的组合电路，称为**多路复用器**。多路复用器通过输入控制信号的值，从一组不同的数据信号选出一个。s为1时输出a，0时输出b



![image-20210707142639284](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707142639284.png)

组合逻辑电路与c语言逻辑表达式的区别

![image-20210707143034327](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707143034327.png)	



### 4.2.3 字级的组合电路和HCL整数表达式

​	通过将逻辑们组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常，我们设计能对数据字进行操作的电路。有一些位级信号，代表一个整数或一些控制模式。例如，我们的处理器设计将包含有很多字，字的大小范围为4位到64位，代表整数、地址、指令代码和寄存器标识符。

![image-20210707144719197](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707144719197.png)	

执行**字级计算的组合电路**根据输入字的各个位，用逻辑门来计算输出字的各个位。例如4-12的组合电路，它测试两个64位子A和B是否相等。也就是，当且仅当A的每一位都和B的相应位相等时，输出才为1。这个电路是用64个图4-10中所示的单个位相等的电路来实现的。这些单个位的电路输出用一个AND门连接起来，形成了这个电路的输出。

![image-20210707145008729](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210707145008729.png)	



![image-20210708113036674](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210708113036674.png)	



图4-13是**字级的多路复用器电路**。

### 4.2.4 集和关系

在处理器中设计中，很多时候都要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。下面来看一个简单的例子，假设想从一个两位信号code中选择高位和低位来为图4-14中的四路复用器产生信号s1和s0，如下图所示：

![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210708141002549.png)	

![image-20210708141037684](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210708141037684.png)	



### 4.2.5 存储器和时钟

组合电路从本质上讲，不存储任何信息。相反，它们只是**简单地响应输入信号**，产生等于输入的某个函数的输出。为了产生**时序电路，也就是有状态并且在这个状态上进行的系统**，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，**时钟是一个周期性信号，决定什么时候把新值加载到设备中**。考虑两类存储器设备：

1. 时钟寄存器存储单个位或字。时钟信号控制寄存器加载输入值。

2. 随即访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。随即访问存储器的例子包括：1）处理器的虚拟内存系统，硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字；2）寄存器文件，在此，寄存器标识符作为地址。在IA32或Y86-64处理器中，寄存器文件有15个程序寄存器（%rax - %r14）

   正如我们看到的那样，在说到硬件和机器级编程时，“寄存器”这个词是有两个细微差别的事情。在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。在机器级编程中，寄存器代表的是cpu中为数不多的可寻址的字，这里的地址时寄存器ID。这些字通常都在寄存器文件中，虽然我们会看到硬件有时把一个字从一个指令传送到另一个指令，以避免先写寄存器文件在读出来的延迟。需要避免歧义时，我们会分别称呼这两类寄存器为硬件寄存器和程序寄存器

   ![image-20210708143512926](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210708143512926.png)	



图4-16更详细地说明了一个硬件寄存器是如何工作的。大多数时候，寄存器都保持在稳定状态（用x表示）,产生的输出等于它的当前状态。信号沿着寄存器前面的组合逻辑传播，这时，产生了一个新的寄存器输入（Y），但只要时钟时低电位的，寄存器的输出就仍然保持不变。当时钟变成高电位的时候，输入信号就加载到寄存器中，成为下一个状态Y，直到下一个时钟上升沿，这个状态一直是寄存器的新输出。关键是**寄存器是作为电路不同部分中的组合逻辑之间的屏障**。每当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。我们的Y86-64处理器会用时钟寄存器保存程序计数器（PC)、条件代码（CC）和程序状态（stat）。



#### 典型的寄存器文件

![image-20210708154103666](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E5%9B%9B%E7%AB%A0.assets/image-20210708154103666.png)	

​	寄存器文件有两个读端口（A和B），还有一个写端口（W）。这样一个多端口随即访问存储器允许同时进行多个读写操作。图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。每个端口都有一个地址输入，表明选择哪个程序寄存器，另外还有一个数据输出或对应程序寄存器的输入值。地址是寄存器标识符。



## 4.3 Y86-64的顺序实现



### 4.3.1 将处理组织成阶段

通常，处理一条指令需要很多操作。将它们组织成某个特殊的阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理，取决于正在执行的指令。创建这样一个框架，我们就能够设计一个充分利用硬件的处理器

1. 取指(fetch)：取指阶段从内存读取指令字节，地址为程序计数器的值。从指令中抽取出指令指示符字节的两个四位部分，称为icode，指令编码，ifun，指令功能。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作指示符RA、RB。它还可能取出一个四字节常数VALC。它按顺序方式计算当前指令的下一条指令的地址valP.也就是说，valp等于pc的值+指令的长度。



# 第五章 优化程序性能

## 5.1 优化编译器的能力和局限性



# 第六章 存储器系统层析

作为一个程序员，你需要理解存储器系统次结构，因为它对应用程序的性能有着巨大的影响。如果你的程序，需要的数据是存储在**cpu寄存器**中的，那么指令的执行期间，在0个周期就能访问它们；如果存储在高速缓存中，需要4-75个周期。如果存储在主存中，需要上百个周期。而如果存储在磁盘上，需要大约几千万个周期。

如果你理解了系统是如何将数据在存储器系统层析结构中上上下下移动的，那么你就可以编写自己的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里CPU能更快地访问到它们。



## 6.1 存储技术

### 6.1.1 随即访问存储器

#### 1.静态RAM

由于SRAM存储器单元的双稳态特性，只要有电，它就会永远保持它的值。即使有干扰来扰乱电压，当干扰消除时，电路就会恢复到稳定值。

#### 2.动态RAM

# 第七章 链接

