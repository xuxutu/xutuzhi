# 深入理解计算机系统

## 第三章 程序的机器级表示

### 3.2.2 代码实例 

### 3.2.2.1如何展示程序的字节表示

![image-20210401132037611](/home/zhaoyong/.config/Typora/typora-user-images/image-20210401132037611.png)	

### 3.2.2.2查看机器代码文件内容的反汇编器

![image-20210401132414628](/home/zhaoyong/.config/Typora/typora-user-images/image-20210401132414628.png)	



![image-20210412124217910](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210412124217910.png)	



### 3.2.2.3 访问机器的低级特性

1.使用汇编代码写整个函数

2.利用GCC的支持，直接在c程序中嵌入汇编代码

#### 3.2.2.3.1 intel 汇编的生成

```
gcc -Og -S -masm=intel mstore.c
```

![image-20210412130813832](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210412130813832.png)	

#### 3.2.2.3.2 C语言访问不到的低级特性

**虽然C编译器在把程序中表达的计算转换到机器代码方面表现出色**，但是仍然有一 些机器特性是C程序访问不到的。例如，每次x86-64处理器执行算术或逻辑运算时,如果得到的运算结果的**低8位中有偶数个l,**那么就会把一个名为PF的1位条件码 (conditioncode)标志设置为1,否则就设置为0。这里的PF表示“parity flag(奇偶标 志)″。在c语言中计算这个信息需要至少7次移位、掩码和异或运算(参见习题2.65)。即使作为每次算术或逻辑运算的一部分,硬件都完成了这项计算,而C程序却无法知道 PF条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。

在C程序中插入汇编代码有两种方法。第一种是,我们可以编写完整的函数,放进 一个独立的汇编代码文件中,让汇编器和链接器把它和用C语言书写的代码合并起来。第二种方法是,我们可以使用GCC的内联汇编(inlineassembly)特性,用asm伪指令可 以在C程序中包舍简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。

当然,在C程序中包含汇缩代码使得这些代码与某类特殊的机器相关(例如x86- 64),所以只应该在想要的特性只能以此种方式才能访问到时才使用它。

![image-20210413131818767](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413131818767.png)	

### 3.3 数据格式

![image-20210413132513647](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413132513647.png)

如图所示,大多数GCC生成的汇编代码指令都有一个字符的后缀,表明操作数的大小。例如,数据传送指令有四个变种: moVb(传送字节)、 moVW(传送字)、 moVl(传送双 字)和movq(传送四字)。后缀‘l’用来表示双字,因为32位数被看成是“长字(long word)。)″。注意,**汇编代码也使用后缀‘l’来表示4字节整数和8字节双精度浮点数**。这不 会产生歧义,因为浮点数使用的是一组完全不同的指令和寄存器。



### 3.4 通用目的寄存器

一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。图3-2显示了这16个寄存器。它们的名字都以笔r 开头,不过后面还跟着一些不同的命名规则的名字,这是由于指令集历史演化造成的。最初的8086中有8个16位的寄存器,即图3-2中的%ax到%bp。每个寄存器都有特殊的用 途,它们的名字就反映了这些不同的用途。扩展到IA32架构时,这些寄存器也扩展成32 位寄存器,标号从%eax到%ebp。扩展到x86-64后,原来的8个寄存器扩展成64位,标 号从%rax到%rbpo除此之外,还增加了8个新的寄存器,它们的标号是按照新的命名规 则制定的,从宅r8到宅r15。

![image-20210413171237073](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413171237073.png)	

如图3-2中嵌套的方框标明的,指令可以对这16个寄存器的低位字节中存放的不同 大小的数据进行操作。字节级操作可以访问最低的字节, 16位操作可以访问最低的2个字 节, 32位操作可以访问最低的4个字节,而64位操作可以访问整个寄存器。

在后面的章节中,我们会展现很多**指令,复制和生成1字节、 2字节、 4字节和8字 节值**。当这些指令以寄存器作为目标时,对于生成小于8字节结果的指令,寄存器中剩下 的字节会怎么样,对此有两条规则:**生成1字节和2字节数字的指令会保持剩下的字节不 变**;生**成4字节数字的指令会把高位4个字节置为O。 后面这条规则是作为从IA32到 x86-64的扩展的一部分而采用的。**

就像图3-2右边的解释说明的那样,在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针持sp,用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外15个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是,有一组标准的编程规范控制着如何使用寄存器来**管理栈**、**传递函数参数**、从**函数的返 回值**,以及**存储局部和临时数据**。我们会在描述过程的实现时(特别是在3.7节中),讲述这些惯例。



#### 3.4.1操作数指示符

![image-20210413175144406](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413175144406.png)

大多数指令有一个或多个操作数(operand),指示出执行一个操作中要使用的源数据 值,以及放置结果的目的位置。X86-64支持多种操作数格式(参见图3-3)。源数据值可以以常数形式给出,或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此,各种不同的操作数的可能性被分为三种类型。第一种类型是**立即数**(immediate),用来表示常数值。在ATT格式的汇编代码中,立即数的书写方式是‘$’后面跟一个用标准C表示法表示的整数,比如, S-577或soxlFo 不同的指令允许的立即数值范围不同,汇编器会自动选择最紧凑的方式进行数值编码。

第二种类型是**寄存器**(register),它表示某个寄存器的内容, 16个寄存器的低位1字节、 2字节、 4字节或8字节中的一个作为操作数,这些字节数分别对应于8位、 16位、 32位或64位。在图3-3中,我们用符号ra来表示任意寄存器α,用引用R[ra]来表示它的值,这是将寄存器集合看成一个数组R,用寄存器标 识符作为索引。

第三类操作数是**内存引用**,它会根据计算出来的地址(通常称为有效地址)访问某个内 存位置。因为将内存看成一个很大的字节数组,我们用符号讥[Addr]表示对存储在内存 中从地址A拍r开始的6个字节值的引用。为了简便,我们通常省去下标b。

如图3-3所示,有多种不同的寻址模式,允许不同形式的内存引用。表中底部用语法 ′仍仍(ro, r., S)表示的是最常用的形式。这样的引用有四个组成部分:一个**立即数偏移Imm** 一个**基址寄存器**Rb,一个**变址寄存器**Ri和一个**比例因子s,**这里s必须是1、 2、 4或者8.基址和变址寄存器都必须是64位寄存器。有效地址被计算为Imm+R[rb]+R[ri].s。引 用数组元素时,会用到这种通用形式。其他形式都是这种通用形式的特殊情况,只是省略 了某些部分。正如我们将看到的,当引用数组和结构元素时,比较复杂的寻址模式是很有 用的。

#### 3.4.2 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用 性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功 能。我们会介绍多种不同的数据传送指令,它们或者源和目的类型不同,或者执行的转换 不同,或者具有的一些副作用不同。在我们的讲述中,把许多不同的指令划分成**指令类**, 每一类中的指令执行相同的操作,只不过操作数大小不同。

图3-4列出的是最简单形式的数据传送指令一MOv类。这些指令把数据从源位置 复制到目的位置,不做任何变化o MOV类由四条指令组成‥ moVb、 moVW、 moVl和 m°vqo这些指令都执行同样的操作;主要区别在于它们操作的数据大小不同:分别是1、 2、 4和8字节。

![image-20210413200658558](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413200658558.png)

源操作数指定的值是一个立即数,存储在寄存器中或者内存中。目的操作数指定一个 位置,要么是一个寄存器或者,要么是一个内存地址o x**86-64加了一条限制,**传送指令的 **两个操作数不能都指向内存位置**。将一个值从一个内存位置复制到另一个内存位置需要两 条指令一**第一条指令将源值加载到寄存器**中,第二条将**该寄存器值写人目的位置**。参考 图3-2,这些指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个,寄存器部分的大小必须与指令最后一个字符(‘b’, ‘w’, ‘l’或‘q’)指定的大小匹配。大多数情况 中, MOv指令只会更新目的操作数指定的那些寄存器字节或内存位置。造成这个例外的 原因是x86-64采用的惯例,**即任何为寄存器生成32位值的指令都会把该寄存器的高位部 分置成0。**

下面的MOv指令示例给出了源和目的类型的五种可能的组合。记住,第一个是源操 作数,第二个是目的操作数：

![image-20210413201143861](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413201143861.png)