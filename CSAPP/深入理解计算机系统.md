# 深入理解计算机系统

## 第三章 程序的机器级表示

### 3.2.2 代码实例 

### 3.2.2.1如何展示程序的字节表示

![image-20210401132037611](/home/zhaoyong/.config/Typora/typora-user-images/image-20210401132037611.png)	

### 3.2.2.2查看机器代码文件内容的反汇编器

![image-20210401132414628](/home/zhaoyong/.config/Typora/typora-user-images/image-20210401132414628.png)	



![image-20210412124217910](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210412124217910.png)	



### 3.2.2.3 访问机器的低级特性

1.使用汇编代码写整个函数

2.利用GCC的支持，直接在c程序中嵌入汇编代码

#### 3.2.2.3.1 intel 汇编的生成

```
gcc -Og -S -masm=intel mstore.c
```

![image-20210412130813832](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210412130813832.png)	

#### 3.2.2.3.2 C语言访问不到的低级特性

**虽然C编译器在把程序中表达的计算转换到机器代码方面表现出色**，但是仍然有一 些机器特性是C程序访问不到的。例如，每次x86-64处理器执行算术或逻辑运算时,如果得到的运算结果的**低8位中有偶数个l,**那么就会把一个名为PF的1位条件码 (conditioncode)标志设置为1,否则就设置为0。这里的PF表示“parity flag(奇偶标 志)″。在c语言中计算这个信息需要至少7次移位、掩码和异或运算(参见习题2.65)。即使作为每次算术或逻辑运算的一部分,硬件都完成了这项计算,而C程序却无法知道 PF条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。

在C程序中插入汇编代码有两种方法。第一种是,我们可以编写完整的函数,放进 一个独立的汇编代码文件中,让汇编器和链接器把它和用C语言书写的代码合并起来。第二种方法是,我们可以使用GCC的内联汇编(inlineassembly)特性,用asm伪指令可 以在C程序中包舍简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。

当然,在C程序中包含汇缩代码使得这些代码与某类特殊的机器相关(例如x86- 64),所以只应该在想要的特性只能以此种方式才能访问到时才使用它。

![image-20210413131818767](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413131818767.png)	

### 3.3 数据格式

![image-20210413132513647](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413132513647.png)

如图所示,大多数GCC生成的汇编代码指令都有一个字符的后缀,表明操作数的大小。例如,数据传送指令有四个变种: moVb(传送字节)、 moVW(传送字)、 moVl(传送双 字)和movq(传送四字)。后缀‘l’用来表示双字,因为32位数被看成是“长字(long word)。)″。注意,**汇编代码也使用后缀‘l’来表示4字节整数和8字节双精度浮点数**。这不 会产生歧义,因为浮点数使用的是一组完全不同的指令和寄存器。



### 3.4 通用目的寄存器

一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。图3-2显示了这16个寄存器。它们的名字都以笔r 开头,不过后面还跟着一些不同的命名规则的名字,这是由于指令集历史演化造成的。最初的8086中有8个16位的寄存器,即图3-2中的%ax到%bp。每个寄存器都有特殊的用 途,它们的名字就反映了这些不同的用途。扩展到IA32架构时,这些寄存器也扩展成32 位寄存器,标号从%eax到%ebp。扩展到x86-64后,原来的8个寄存器扩展成64位,标 号从%rax到%rbpo除此之外,还增加了8个新的寄存器,它们的标号是按照新的命名规 则制定的,从宅r8到宅r15。

![image-20210413171237073](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413171237073.png)	

如图3-2中嵌套的方框标明的,指令可以对这16个寄存器的低位字节中存放的不同 大小的数据进行操作。字节级操作可以访问最低的字节, 16位操作可以访问最低的2个字 节, 32位操作可以访问最低的4个字节,而64位操作可以访问整个寄存器。

在后面的章节中,我们会展现很多**指令,复制和生成1字节、 2字节、 4字节和8字 节值**。当这些指令以寄存器作为目标时,对于生成小于8字节结果的指令,寄存器中剩下 的字节会怎么样,对此有两条规则:**生成1字节和2字节数字的指令会保持剩下的字节不 变**;生**成4字节数字的指令会把高位4个字节置为O。 后面这条规则是作为从IA32到 x86-64的扩展的一部分而采用的。**

就像图3-2右边的解释说明的那样,在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针持sp,用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外15个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是,有一组标准的编程规范控制着如何使用寄存器来**管理栈**、**传递函数参数**、从**函数的返 回值**,以及**存储局部和临时数据**。我们会在描述过程的实现时(特别是在3.7节中),讲述这些惯例。



#### 3.4.1操作数指示符

![image-20210413175144406](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413175144406.png)

大多数指令有一个或多个操作数(operand),指示出执行一个操作中要使用的源数据 值,以及放置结果的目的位置。X86-64支持多种操作数格式(参见图3-3)。源数据值可以以常数形式给出,或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此,各种不同的操作数的可能性被分为三种类型。第一种类型是**立即数**(immediate),用来表示常数值。在ATT格式的汇编代码中,立即数的书写方式是‘$’后面跟一个用标准C表示法表示的整数,比如, S-577或soxlFo 不同的指令允许的立即数值范围不同,汇编器会自动选择最紧凑的方式进行数值编码。

第二种类型是**寄存器**(register),它表示某个寄存器的内容, 16个寄存器的低位1字节、 2字节、 4字节或8字节中的一个作为操作数,这些字节数分别对应于8位、 16位、 32位或64位。在图3-3中,我们用符号ra来表示任意寄存器α,用引用R[ra]来表示它的值,这是将寄存器集合看成一个数组R,用寄存器标 识符作为索引。

第三类操作数是**内存引用**,它会根据计算出来的地址(通常称为有效地址)访问某个内 存位置。因为将内存看成一个很大的字节数组,我们用符号讥[Addr]表示对存储在内存 中从地址A拍r开始的6个字节值的引用。为了简便,我们通常省去下标b。

如图3-3所示,有多种不同的寻址模式,允许不同形式的内存引用。表中底部用语法 ′仍仍(ro, r., S)表示的是最常用的形式。这样的引用有四个组成部分:一个**立即数偏移Imm** 一个**基址寄存器**Rb,一个**变址寄存器**Ri和一个**比例因子s,**这里s必须是1、 2、 4或者8.基址和变址寄存器都必须是64位寄存器。有效地址被计算为Imm+R[rb]+R[ri].s。引 用数组元素时,会用到这种通用形式。其他形式都是这种通用形式的特殊情况,只是省略 了某些部分。正如我们将看到的,当引用数组和结构元素时,比较复杂的寻址模式是很有 用的。

#### 3.4.2 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用 性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功 能。我们会介绍多种不同的数据传送指令,它们或者源和目的类型不同,或者执行的转换 不同,或者具有的一些副作用不同。在我们的讲述中,把许多不同的指令划分成**指令类**, 每一类中的指令执行相同的操作,只不过操作数大小不同。

图3-4列出的是最简单形式的数据传送指令一MOv类。这些指令把数据从源位置 复制到目的位置,不做任何变化o MOV类由四条指令组成‥ moVb、 moVW、 moVl和 m°vqo这些指令都执行同样的操作;主要区别在于它们操作的数据大小不同:分别是1、 2、 4和8字节。

![image-20210413200658558](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413200658558.png)

源操作数指定的值是一个立即数,存储在寄存器中或者内存中。目的操作数指定一个 位置,要么是一个寄存器或者,要么是一个内存地址o x**86-64加了一条限制,**传送指令的 **两个操作数不能都指向内存位置**。将一个值从一个内存位置复制到另一个内存位置需要两 条指令一**第一条指令将源值加载到寄存器**中,第二条将**该寄存器值写人目的位置**。参考 图3-2,这些指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个,寄存器部分的大小必须与指令最后一个字符(‘b’, ‘w’, ‘l’或‘q’)指定的大小匹配。大多数情况 中, MOv指令只会更新目的操作数指定的那些寄存器字节或内存位置。造成这个例外的 原因是x86-64采用的惯例,**即任何为寄存器生成32位值的指令都会把该寄存器的高位部 分置成0。**

下面的MOv指令示例给出了源和目的类型的五种可能的组合。记住,第一个是源操 作数,第二个是目的操作数：

![image-20210413201143861](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413201143861.png)

图3-4中记录的最后一条指令是处理64位立即数数据的。常规的m〇vq指令只能以袁 示为32位补码数字的立即数作为源操作数,然后把这个值符号扩展得到64位的值,放到 目的位置o **movabsq**指令能够以任意64位立即数值作为源操作数,并且只能以寄存器作 为目的。

![image-20210414130240628](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210414130240628.png)

图3-5和图3-6记录的是两类数据移动指令,在将较小的源值复制到较大的目的时使 用。所有这些指令都把数据从源(在寄存器或内存中)复制到目的寄存器。MOvZ类中的 指令把目的中剩余的字节填充为0,而MOvS类中的指令通过符号扩展来填充,把源操作 的最高位进行复制。可以观察到,每条指令名字的最后两个字符都是大小指示符:第一个 字符指定源的大小,而第二个指明目的的大小。正如看到的那样,这两个类中每个都有三 条指令,包括了所有的源大小为1个和2个字节、目的大小为2个和4个的情况,当然只 考虑目的大于源的情况。

##### 3.4.2.1理解数据传送如何改变目的寄存器

正如我们描述的那样,关于数据传送指令是否以及如何修改目的寄存器的高位字节 有两种不同的方法。下面这段代码序列会说明其差别: 

![image-20210414131252753](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210414131252753.png)

在接下来的讨论中,我们使用十六进制表示。在这个例子中,第1行的指令把寄存器宅 rax初始化为位模式00112233445566770 剩下的指令的源操作数值是立即数值一10 回想一 1的十六进制表示形如FF…F,这里F的数量是表述中字节数量的两倍。因此m°vb指令 (第2行)把扯ax的低位字节设置为FF,而mow指令(第3行)把低2位字节设置为FFFF, 剩下的字节保持不变. movl指令(第4行)将低4个字节设置为FFFFFFFF,同时把高位4 字节设置为000000000最后m°vq指令(第5行)把整个寄存器设置为FFFFFFFFFFFFFFFF.

注意图3-5中并没有一条明确的指令**把4字节源值零扩展到8字节目的**。这样的指令 逻辑上应该被命名为movzlq,但是并没有这样的指令.。不过,这样的数据传送可以用以 寄存器为目的的movl指令来实现.现。这一**投术利用的属性是******,生成4字节值并以寄存器作 为目的的指令会把高4字节置为0。***

对于64位的目标,**所有三种源类型都有对应的符号扩 展传送,而只有两种较小的源类型有零扩展传送**。

图3-6还给出cltq指令。这条指令没有操作数:它总是以寄存器?eax作为源,frax作 为符号扩展结果的目的。它的效果与指令m〇VSlq %eax,frax完全一致,不过编码更紧凑。

**x86-64中的内存引用总是用四字长寄存器给出**

##### 3.4.2.2 mov指令常见错误

![image-20210414194441242](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210414194441242.png)

#### 3.4.3 数据传送示例

```
   3 long exchange(long* xp, long y)
  4 {
  5     long x = *xp;
  6     *xp = y;
  7     return x;
  8 }
 
 9 exchange:
 10     movq    (%rdi), %rax
 11     movq    %rsi, (%rdi)
 12     ret
```

如图3-7b所示,函数exchange由三条指令实现:两个数据传送(movq),加上一条返回函数被调用点的指令(ret)。我们会在3.7节中讲述函数调用和返回的细节。在此之前,**知道参数通过寄存器传递给函数就足够**了。我们对汇编代码添加注释来加以说明。**函数通过把值存储在寄存器宅rax或该寄存器的某个低位部分中返回**。

当过程开始执行时,过程参数xp和y分别存储在寄存器%rdi和%rsi中。然后,指 令2从内存中读出x,把它存放到寄存器宅rax中,直接实现了C程序中的操作x=★xpo稍 后,用寄存器持ax从这个函数返回一个值,因而返回值就是xo指令3将y写人到寄存 器%rdi中的xp指向的内存位置,直接实现了操作★xp=yo这个例子说明了如**何用MOV 指令从内存中读值到寄存器(第2行),如何从寄存器写到内存(第3行)。**

关于这段汇编代码有两点值得注意。首先,我们看到C语言中**所谓的“指针”其实就 是地址**。**间接引用指针**就是将**该指针放在一个寄存器中,**然后在**内存引用中使用这个寄存 器**。其次,**像x这样的局部变量**通常是**保存在寄存器**中,而不是内存中。**访问寄存器比访 问内存要快得多**。

##### 3.4.3.1 汇编实现强制类型转换

![image-20210416124744054](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416124744054.png)



#### 3.4.4 压入和弹出栈数据

![image-20210416125056168](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416125056168.png)

最后两个数据传送操作可以将数据压人程序栈中,以及从程序栈中弹出数据,如图3-8 所示。正如我们将看到的,栈在处理过程调用中起到至关重要的作用。栈是一种数据结 构,可以添加或者删除值,不过要遵循“后进先出”的原则。通过push操作把数据压人 栈中,通过pop操作删除数据;它具有一个属性:弹出的值永远是最近被压人而且仍然在 栈中的值。栈可以实现为一个数组,总是从数组的一端插人和删除元素。这一端被称为栈 项。在x86-64中,程序栈存放在内存中某个区域。如图3-9所示,栈向下增长,这样一 来,栈顶元素的地址是所有栈中元素地址中最低的。 (根据惯例,我们的栈是倒过来画的, 栈“顶”在图的底部。)栈指针持sp保存着栈顶元素的地址。

pushq指令的功能是把数据压人到栈上,而popq指令是弹出数据。这些指令都只有 一个操作数一压人的数据源和弹出的数据目的。

将一个四字值压人栈中,首先要将栈指针减8,然后将值写到新的栈顶地址。因此, 指令pushq %rbp的行为等价于下面两条指令:

![image-20210416125845715](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416125845715.png)

它们之间的区别是在机器代码中pushq指令编码为**1个字节**,而上面那两条指令一共需要 **8个字节**。

![image-20210416130051744](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416130051744.png)

图3-9中前两栏给出的是,当%rsp为OxlO8,%rax为Ox123时,执行指令 pushq%rax的效果。首先%rsp会减8,得到Oxlo,然后会将Ox123存放到内存地址 Oxlo处。



弹出一个四字的操作包括从栈顶位置读出数据,然后将栈指针加80 因此,指令p〇pq 宅rax等价于下面两条指令:

![image-20210416175121779](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416175121779.png)

图3-9的第三栏说明的是在执行完pushq后立即执行指令popq frdx的效果。先从内 存中读出值Ox123,再写到寄存器%rdx中,然后,寄存器%rsp的值将增加回到OxlO80 如图中所示,值Ox123仍然会保持在内存位置OxloO中,直到被覆盖(例如被另一条人栈 操作覆盖)。无论如何,%rsp指向的地址总是栈顶。 因为栈和程序代码以及其他形式的程序数据都是放在同一内存中,所以程序可以用标 准的内存寻址方法访问栈内的任意位置。例如,假设栈顶元素是四字,指令movq8(宅 rsp) ,笔rdx会将第二个四字从栈中复制到寄存器笔rdxo



### 3.5 算术和逻辑操作

**整数算术操作。加载有效地址(leaq)指令通常用来执行简单的算术操作。其余的指令 是更加标准的一元或二元操作。我们用>> A和>>.来分别表示算术右移和逻辑右移。 注意,这里的操作顺序与ATT格式的汇编代码中的相反**

![image-20210419124156141](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210419124156141.png)

图3-10列出了x86-64的一些整数和逻辑操.作。大多数操作都分成了指令类,这些指 令类有各种带不同大小操作数的变种(只有Ieaq没有其他大小的变种)。例如,指令类 ADD由四条加法指令组成‥ addb、 addw、 addl和addq,分别是字节加法、字加法、双 字加法和四字加法。事实上,给出的每个指令类都有对这四种不同大小数据的指令。这些操作被分为四组:加载有效地址、一元操作、二元操作和移位.二元操作有两个操作数, 而一元操作有一个操作数。这些操作数的描述方法与3.4节中所讲的一样。

#### 3.5.1加载有效地址 leap

加载有效地址(load effective address)指令Ieaq实际上是movq指令的变形.它的指 令形式是从内存读数据到寄存器,但实际上它根本就没有引用内存。它的第一个操作数看 上去是一个内存引用,但该指令并不是从指定的位置读人数据,而是将有效地址写人到目 的操作数。在图3-10中我们用C语言的地址操作符&s说明.这种计算这条指令可以**为后 面的内存引用产生指针**.另外,它还可以**简洁地描述普通的算术操作**。例如,如果寄存 器%rdx的值为x,那指令Ieaq 7(%rdx,%rdx,4),frax将设置寄存器%rax的值为5工+ 70编译器经常发现Ieaq的一些灵活用法,根本就与有效地址计算无关。目**的操作数必须 是一个寄存器**。

为了说明Ieaq在编译出的代码中的使用,看看下面这个C程序:

```
  1 
  2 long scale(long x, long y, long z)
  3 {
  4     long t = x + 4 * y + 12 * z;
  5     return t;
  6 }

```

```
  2 x in rdi, y in rsi z in rdx
  3 
  4 scale:
  5     leaq    (%rdi,%rsi,4), %rax 
  6     
  7     //x + 4y
  8     
  9     leaq    (%rdx,%rdx,2), %rcx
 10     
 11     z + 2z = 3z
 12     
 13     leaq    0(,%rcx,4), %rdx
 14     
 15     3z * 4 = 12z
 16     
 17     addq    %rdx, %rax
 18     
 19     x + 4y + 12z
 20     ret

```

leaq指令能执行加法和有限形式的乘法,在编译如上简单的算术表达式时,是很有用处的。

##### 3.5.1.1 xor

```
xorq %rdx,%rdx
1.这个指令将%rdx置为0,运用了对任意x，x^x=0 这一属性。它对应于c语句x=0。
2.将寄存器%rdx设置为0的更直接的方法是用指令 movq $0, %rdx
3.xorq 实现需要三个字节;movq 实现需要7个字节。
```

**其它将%rdx设置为0的方法都依赖于这样一个属性，即任何更新低位4字节的指令都会把高位字节设置为0.因此我们可以使用xorl %edx，%edx（2字节）或movl $0, %edx(5字节)**



#### 3.5.2 一元和二元操作

第二组中的操作是一元操作,只有一个操作数,既是源又是目的。这个操作数可以是 一个寄存器,也可以是一个内存位置。比如说,指令incq(%rsp)会使栈顶的8字节元素 加10 这种语法让人想起C语言中的加1运算符(++)和减1运算符(一一)。

第三组是二元操作,其中,第二个操作数既是源又是目的。这种语法让人想起C语言 中的赋值运算符,例如x一=yo不过,要注意,源操作数是第一个,目的操作数是第二个, 对于不可交换操作来说,这看上去很奇特。例如,指令subq frax,frdx使寄存器frdx的 值减去%rax中的值。 (**将指令解读成“从%rdx中减去?rax**”会有所帮助。)第一个操作数 可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意, **当第二个操作数为内存地址时,处理器必须从内存读出值,执行操作,再把结果写回 内存**。



#### 3.5.3 移位操作

最后一组是移位操作,先给出移位量,然后第二项给出的是要移位的数。可以进行算 术和逻辑右移。移位量可以是一个立即数,或者放在单字节寄存器宅cl中。 (这些指令很 特别,因为只允许以这个特定的寄存器作为操作数。)原则上来说, 1个字节的移位量使得 移位量的编码范围可以达到28-1==2550.x86-64中,移位操作对砂位长的数据值进行操 作,移位量是由宅cl寄存器的低仍位决定的,这里2加…砂。高位会被忽略。**所以,例如当 寄存器%cl的十六进制值为OxFF时,指令salb会移7位, Salw会移15位, Sall会移 31位,而salq会移63位。**



#### 3.5.5 特殊的算术操作

正如我们在2.3节中看到的,两个64位有符号或无符号整数相乘得到的乘积需要128 位来表示。x86-64指令集对128位(16字节)数的操作提供有限的支持。延续字(2字节)、 双字(4字节)和四字(8字节)的命名惯例, Intel把16字节的数称为八字(oct word)。图3-12 描述的是支持产生两个64位数字的全128位乘积以及整数除法的指令。

![image-20210428140131241](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210428140131241.png)

imulq指令有两种不同的形式。其中一种,如图3-10所示,是IMUL指令类中的一 种。这种形式的imulq指令是一个“双操作数”乘洼指令。它从两个64位操作数产生一 个64位乘积。

此外, x86-64指令集还提供了两条不同的“单操作数”乘法指令以计算两个64位 值的全128位乘积积一一个是无符号数乘法(mulq),而另一个是补码乘法(imulq)。这两 条指令都要求一**个参数必须在寄存器%rax中**,而另一个作为指令的源操作数给出。然后 乘**积存放在寄存器%rdx(高64位)和%rax(低64位)中**。虽然imulq这个名字可以用于两 个不同的乘洼操作,但是汇编器能够通过计算操作数的数目,分辨出想用哪条指令。

下面这段C代码是一个示例,说明了如何从两个无符号64位数字x和y生成128位 的乘积:

```
  1 #include <inttypes.h>
  2 
  3 //dest in %rdi, x in %rsi, y in %rdx
  4 
  5 /*
  6   1     movq    %rsi, %rax
  7   2     mulq    %rdx
  8   3     movq    %rax, (%rdi)
  9   4     movq    %rdx, 8(%rdi)
 10   5     ret
 11 */
 12 
 13 typedef unsigned __int128 uint128_t;
 14 
 15 void store_uprod(uint128_t* dest, uint64_t x, uint64_t y )
 16 {
 17     *dest = x * (uint128_t) y;
 18 }
 19
```

可以观察到,存储乘积需要两个movq指令:一个存储低8个字节(第4行),一个存 储高8个字节(第5行)。由于生成这段代码针对的是**小端法机器**,所以高位字节存储在大 地址,正如地址8(%rdi)表明的那样。

前面的算术运算表(图3-10)没有列出除法或取模操作。这些操作是由单操作数除法指 令来提供的,类似于单操作数乘法指令。有符号除法指令idivl将寄存器%rdx(高64位) 和持ax(低64位)中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存 储在寄存器持ax中,将余数存储在寄存器笔rdx中。

对于大多数64位除法应用来说,除数也常常是一个64位的值。这个值应该存放在宅 rax中,frdx的位应该设置为全0(无符号运算)或者%rax的符号位(有符号运算)。后面这 个操作可以用指令cqto来完成。**这条指令不需要操作数一它隐含读出扯%rax的符号位, 并将它复制到%rdx的所有位。**

```
  1 void remdiv(long x, long y, long* qp, long* rp)
  2 {
  3     long q = x / y;
  4     long r = x % y;
  5     *qp = q;
  6     *rp = r;
  7 }
  8     
  9 /*  
 10 
 11     //x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
 12   8     movq    %rdi, %rax
 13   9     movq    %rdx, %rdi
 14 //在上述代码中,必须首先把参数qp保存到另一个寄存器中(第2行),因为除法操作
 15 //要使用参数寄存器扯%rdx
 16  10     cqto
 17 //它隐含读出扯%rax的符号位,
 18 //并将它复制到笔%rdx的所有位。
 19  11     idivq   %rsi
 20 //有符号除法指令idivl将寄存器%rdx(高64位)
 21 //和持%rax(低64位)中的128位数作为被除数,而除数作为指令的操作数给出
 22  12     movq    %rax, (%rdi)
 23 //指令将商存储在寄存器持%rax中
 24  13     movq    %rdx, (%rcx)
 25 //将余数存储在寄存器笔%rdx中。
 26  14     ret
 27 */ 
```

**无符号除法使用divq指令。通常,寄存器%rdx会事先设置为0.**



### 3.6 控制

到目前为止,我们只考虑了直线代码的行为,也就是指令一条接着一条顺序地执行.C语言中的某些结构,比如条件语旬、循环语旬和分支语句,要求有条件的执行,根据数 据测试的结果来决定操作执行的顺序。机器代码提供**两种基本的低级机制**来实现**有条件的 行为**:**测试数据值**,然后根据测试的结果来改变**控制流或者数据流**。

与**数据相关的控制流**是实现有条件行为的更一般和更常见的方法,所以我们先来介绍 它。通常, C语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序,顺序 执行的。用jump指令可以改变一组机器代码指令的执行顺序, jump指令指定控制应该被 传递到程序的某个其他部分,可能是依赖于某个测试的结果.编**译器必须产生构建在这种 低级机制基础之上的指令序列,来实现C语言的控制结构**。

本文会先涉及**实现条件操作**的两种方式,然后描述**表达循环**和**switch**语句的方法.

#### 3.6.1条件码

除了整数寄存器, CPU还维护着一组单个位的条件码(condition code)寄存器，器,它们 描述了最近的**算术或逻辑操作**的**属性**。可以检测这些寄存器来执行条件分支指令。最常用 的条件码有:

**CF:进位标志。**最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。

**ZF:零标志**。最近的操作得出的结果为0。

**SF:符号标志**。最近的操作得到的结果为负数o

**OF:溢出标志。**最近的操作导致一个补码溢出一正溢出或负溢出。



比如说,假设我们用一条ADD指令完成等价于C表达式t=a+ b的功能,这里变量 a、 b和t都是整型的。然后,根据下面的C表达式来设置条件码:

![image-20210428165207176](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210428165207176.png)	

I**eaq指令不改变任何条件码**,因为它是用来进行地址计算的。除此之外,图3-10中 列出的所有指令都会设置条件码。对于**逻辑操作,**例如xor,进位标志和溢出标志会设 置成0.对于**移位操作**,进位标志将设置为最后一个被移出的位,而溢出标志设置为0.**INC和DEC**指令会**设置溢出和零标志,**但是不会改变进位标志,**至于原因,我们就不在 这里深人探讨了**。



![image-20210428165843066](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210428165843066.png)	



除了图3-10中的指令会设置条件 码,还有**两类指令**(有8、 16、 32和64 位形式),它们只**设置条件码**而不改变任 何其他寄存器;如图3-13所示o CMP指 令根据两个操作数之差来设置条件码。除了只设置条件码而不更新目的寄存器 之外, **CMP指令**与**SUB指令**的行为是 一样的。在ATT格式中,列出操作数的 顺序是相反的,这使代码有点难读。如 果两个操作数相等,这些指令会将零标 志设置为1,而其他的标志可以用来确定 两个操作数之间的大小关系.**TEST**指 令的行为与AND指令一样,除了它们只 设置条件码而不改变目的寄存器的值。典型的用法是,**两个操作数是一样的(例如, TESTq %rax,%rax用来检查%rax是负数、 零,还是正数**),或**其中的一个操作数是一个掩码,用来指示哪些位应该被测试**。

#### 3.6.2 访问条件码	

![image-20210428182419167](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210428182419167.png)	

条件码通常不会直接读取,常用的使用方法有三种: 1)可以根据条件码的某种组合, 将一个字节设置为0或者1, 2)可以条件跳转到程序的某个其他的部分, 3)可以有条件地 传送数据。对于第一种情况,图3-14中描述的指令根据条件码的某种组合,将一个字节 设置为0或者1。我们将这一整类指令称为SET指令;它们之间的区别就在于它们考虑的 条件码的组合是什么,，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。这些 指令的后缀表**示不同的条件**而不是操作数大小,了解这一点很重要。例如,指令setl和 setb表示“小于时设置(set less)”和“低于时设置(set below)”,而不是“设置长字(set long word)”和“设置字节(set byte)”。

**一条SET指令的目的操作数**是**低位单字节寄存器元素(图3-2)之一**,或是**一个字节的 内存位置**,指令会将这个字节设置成0或者1。为了得到一个32位或64位结果,我们必 须对高位清零。一个计算C语言表达式**a< b**的典型指令序列如下所示,这里a和b都是 long类型:

![image-20210428183310055](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210428183310055.png)	

注意cmpq指令的比较顺序(第2行)。虽然参数列出的顺序先是%rsi(b)再是%rdi(a), 实际上比较的是a和b，还要记得,正如在3.4.2节中讨论过的那样, moVZbl指令不仅会 把%eax的高3个字节清零,还会把整个寄存器%rax的高4个字节都清零。

某些底层的机器指令可能有多个名字,我们称之为“同义名(synonym)″。比如说, setg(表示“设置大于”)和setnle(表示“设置不小于等于”)指的就是同一条机器指令。 编译器和反汇编器会随意决定使用哪个名字。

虽然所有的算术和逻辑操作都会设置条件码,但是各个SET命令的描述都适用 的情况是:执行比较指令,根据计算t=a-b设置条件码。更具体地说,假设α、 6和‘ 分别是变量a、 b和t的补码形式表示的整数,因此仁==α一∴6,这里砂取决于α和6 的大小。

来看sete的情况,即“当相等时设置(setwhenequal)”指令。当当cz…Z,时,会得到r=O, 因此零标志置位就表示相等。类似地，考虑用setl,即“当小于时设置(set whenless)”指令,测试一个有符号比较。当没有发生溢出时(OF设置为0就表明无溢出),我们有当α一b<0 时a<b,,将SF设置为1即指明这一点,而当a-b>=0时a>b,由sF设置为0指明.另一 方面,当发生溢出时,我们有当α一b>0(负溢出)时a<b,而当a-b<0(正溢出)时α>b.当a=b时,不会有溢出。

注意到机器代码如何区分有符号和无符号值是很重要的。**同C语言不同,机器代码不 会将每个程序值都和一个数据类型联系起来。**相反,大多数情况下,机器代码对于有符号 和无符号两种情况都使用一样的指令,这是因为许多算术运算对无符号和补码算术都有一 样的位级行为。有些情况需要用不同的指令来处理有符号和无符号操作,例如,使用不同 版本的右移、除法和乘法指令,以及不同的条件码组合。

#### 3.6.3 跳转指令

正常执行的情况下,指令接照它们出现的顺序一条一条地执行。跳转(jump)指令会导 致执行切换到程序中一个全新的位置。在汇编代码中,这些跳转的目的地通常用一个标号 (label))指明。考虑下面的汇编代码序列(完全是人为编造的):

![image-20210429095325596](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429095325596.png)	

指令jmp.Ll会导致程序跳过movq指令,而从popq指令开始继续执行在产生目标 代码文件时,**汇编器**会确定**所有带标号指令的地址**,并将**跳转目标**(目的指令的地址)编码 为**跳转指令**的一部分。

![image-20210429095606301](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429095606301.png)	

图3-15列举了不同的跳转指令。jmp指令是无条件跳转。它可以是**直接跳转**,即**跳转 目标**是**作为指令的一部分**编码的;也可以是间接跳转,即跳转目标是从寄存器或内存位置 中读出的。汇编语言中,直接跳转是给出一个标号作为跳转目标的,例如上面所示代码中 的标号“.Ll″。间接跳转的写法是‘★ ’后面跟一个操作数指示符,使用图3-3中描述的内 存操作数格式中的一种。举个例子,指令

```
jmp *%rax
```

用寄存器%rax中的值作为跳转目标,而指令

```
jmp*(%rax)
```

以%rax中的值作为读地址,从内存中读出跳转目标。

表中所示的其他跳转指令都是有条件的,它们根据**条件码的某种组合**,或者**跳转**, 或者**继续执行代码序列中下一条指令**。这些指令的名字和跳转条件与sET指令的名字和 设置条件是相匹配的(参见图3-14）。)同SET指令一样,一些底层的机器指令有多个名字。 **条件跳转只能是直接跳转**。



#### 3.6.4 跳转指令的编码

虽然我们不关心机器代码格式的细节,但是理解跳转指令的目标如何编码,这对第**7章研究链接**非常重要。此外,它也能帮助理**解反汇编器**的输出。在汇编代码中,跳转目标 用符号标号书写。汇编器,以及后来的链接器,会产生跳转目标的适当编码。跳转指令有 几种不同的编码,但是最常用都是PC相对的(PC-relative)。也就是,它们会将**目标指令 的地址与紧跟在跳转指令**后面那条指令的地址之间的差作为编码。这些地址偏移量可以编 码为l、 2或4个字节。第二种编码方洼是给出“绝对”地址,用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。

下面是一个PC相对寻址的例子,这个函数的汇编代码由编译文件branch.c产生。下面是一个PC相对寻址的例子,这个函数的汇编代码由编译文件branch.c产生。它 包含两个跳转:第2行的jmp指令前向跳转到更高的地址,而第7行的jg指令后向跳转 到较低的地址。

![image-20210429103945677](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429103945677.png)	

右边反汇编器产生的注释中,第2行中跳转指令的跳转目标指明为0x8,第5行中跳 转指令的跳转目标是0x5。不过,观察指令的 字节编码,会看到第一条跳转指令的目标编码(在第二个字节中)为0x03。把它加上Ox5, 也就是下一条指令的地址,就得到跳转目标地址Ox8,也就是第4行指令的地址。

类似,第二个跳转指令的目标用单字节、补码表示编码为Oxf8(十进制一8)。将这个数 加上Oxd(十进制13),即第6行指令的地址,我们得到Ox5,即第3行指令的地址。**这些例子说明,当执行PC相对寻址时,程序计数器的值是跳转指令后面的那条指令 的地址,而不是跳转指令本身的地址。**这种惯例可以追溯到早期的实现,当时的处理器会 将**更新程序计数器作为执行一条指令的第一步**。

下面是链接后的程序反汇编版本:

![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429130728971.png)	

这些指令被重定位到不同的地址,但是第2行和第5行中跳转目标的编码并没有变。通过使用与PC相对的**跳转目标编码,**指令编码很简洁(只需要2个字节),而且目标代码 **可以不做改变就移到内存中不同的位置**。

##### 3.6.4.1 指令rep和量repz有什么用

本节开始的汇编代码的第8行包舍指令组合rep; ret.它们在反汇编代码中(第6 行)对应于repz retq.可以推测出repz是rep的同义名,而retq是ret的同义名。查阅Intel和AMD有关rep的文档,我们发现它通常用来实现重复的字符串操作[3, 51]。在这里用它似乎很不合适。这个问题的答案可以在AMD给编译器编写者的指导 意见书[1]中找到.他们建议用**rep后面跟ret的组合来避兔使ret指令成为条件跳转 指令的目标**。如果没有rep指令,当分支不跳转时, jg指令(汇编代码的第7行)会继 续到ret指令.根据AMD的说法,当ret指令通过跳转指令到达时,处理器不能正确 预测ret指令的目的。这里的rep指令就是作为一种空操作,困此作为跳转目的插入 它,赊了能使代码在AMD上运行得更快之外,不会改变代码的其他行为。在本书后面 其他代码中再遇到rep或repz时,我们可以很放心地无视它们。

**跳转指令提供了一种实现条件执行(if)和几种不同循环结构的方式.**



#### 3.6.5 用条件控制来实现条件分支

![image-20210429140151322](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429140151322.png)	![image-20210429140907710](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429140907710.png)	

![image-20210429141956088](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429141956088.png)	

将条件表达式和语句从C语言翻译成机器代码,最常用的方式是结合有条件和无条件 跳转。 (另一种方式在3.6.6节中会看到,有些条件可以用数据的条件转移实现,而不是 用控制的条件转移来实现。)例如,图3-16a给出了一个计算两数之差绝对值的函数的C代 码.这个函数有一个副作用,会增加两个计数器,编码为全局变量lt_cnt和ge_cnt之 一. GCC产生的汇编代码如图3-16c所指示。示。把这个机器代码再转换成C语言,我们称之为 函数gotodiff_Se(图3-图3-16c所示。把这个机器代码再转换成C语言,我们称之为 函数gotodiff_Se(图3-16b)。它使用了C语言中的goto语旬,这个语句类似于汇编代 码中的无条件跳转。使用goto语句通常认为是一种不好的编程风格,因为它会使代码非常难以阅读和调试。本文中使用goto语旬,是为了构造描述汇编代码程序控制流的C程 序。我们称这样的编程风格为“goto代码”。

在goto代码中(图3-16b),第5行中的gotox_ge_y语句会导致跳转到第9行中的标 号x_ge_y处(当z>y时会进行跳转)。从这一点继续执行,完成函数absdiff_Se的 else部分并返回。另一方面,如果测试x>=y失败,程序会计算absdiff_Se的if部分 指定的步骤并返回。

汇编代码的实现(图3-16c)首先比较了两个操作数(第2行),设置条件码.如果比较 的结果表明工大于或者等于y,那么它就会跳转到第8行,增加全局变量ge_cnt,计算x -y作为返回值并返回。由此我们可以看到a**bsdiff_Se对应汇编代码的控制流**非常**类似于 gotodiff_Se的goto代码**。

C语言中的if-else语句的通用形式模板如下:

![image-20210429145356176](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429145356176.png)	

这里‘“十℃工卸一是一个整数表达式,它的取值为O(解释为“假”)或者为非0(解释为“真”)。两个分支语句中(砌锄飞比比加e加或e打扩J比比仍绷‘)只会执行一个。

对于这种通用形式,汇编实现通常会使用下面这种形式,这里,我们用C语法来描述 控制流,

![image-20210429145537362](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429145537362.png)	

也就是,汇编器为‘加″飞比比加助‘和〆sg一扔‘彻6加产生备自的代码块。它会插人条件 和无条件分支,以保证能执行正确的代码块。



#### 3.6.6 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时,程序沿着一条 执行路径执行,而当条件不满足时,就走另一条路径。这种机制简单而通用,但是在现代 处理器上,它可能会非常低效。

**一种替代的策略是使用数据的条件转移。**这种方法计算一个条件操作的两种结果,然 后再根据条件是否满足从中选取一个。只有在一些受限制的情况中,这种策略才可行,但 是如果可行,就可以用一条简单的条件传送指令来实现它,条件传送指令更符合现代处理 器的性能特性。我们将介绍这一策略,以及它在x86-64上的实现。

![image-20210429163116943](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210429163116943.png)	

图3-17a给出了一个可以用条件传送编译的示例代码码。这个函数计算参数x和y差的 绝对值,和前面的例子一样(图3-16))。不过前面的例子中,分支里有副作用,会修玫It cnt或ge_Cnt的值,而这个版本只是简单地计算函数要返回的值.

##### 3.6.6.1 cmovge

GCC为该函数产生的汇编代码如图3-17c所示,它与图3-17b中所示的C函数 cmovdiff有相似的形式。研究这个C版本,我们可以看到它既计算了y-X,也计算了x-y, 分别命名为rval和evall.然后它再测试x是否大于等于y,如果是,就在函数返回rval 前,将eval复制到rval中。图3-17c中的汇编代码有相同的逻辑。关键就在于汇编代码的那 条**cmovge**指令(第7行)实现了cmovdiff的**条件赋值**(第8行)。只有当第6行的cmpq指令表明 一个值大于等于另一个值(正如后缀ge表明的那样)时,才会把数据源寄存器传送到目的。

##### **3.6.6.2 现代处理器运行-流水线**

为了理解为什么**基于条件数据传送的代码会比基于条件控制转移的代码(如图3-16中 那样)性能要好**,我们必须了解一些美于现代处理器如何运行的知识。正如我们将在第4 章和第5章中看到的,处理器通过使用**流水线(pipelining)**来获得**高性能**,在流水线中, 一条指令的处理要经过一系列的阶段,每个阶段执行所需操作的一小部分(例如,从内存取 指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据,以及更新程序计数 器)。这种方法通过重叠连续指令的步骤来获得高性能,例如,在取一条指令的同时,执 行它前面一条指令的算术运算。要做到这一点,要求能够事先确定要执行的指令序列,这 样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转(也称为“分支″)时,只 有当分支条件求值完成之后,才能决定分支往哪边走。处理器采用非常精密的分支预测逻 辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠(现代微处理器设计试图达 到90%以上的成功率),指令流水线中就会充满着指令。另一方面,错误预测一个跳转, 要求处理器丢掉它为该跳转指令后所有指令已做的工作,然后再开始用从正确位置处起始 的指令去填充流水线。正如我们会看到的,这样一个错误预测会招致很严重的惩罚,浪费 大约15-30个时钟周期,导致程序性能严重下降。

作为一个示例,我们在Intel Haswe11处理器上运行absdiff函数,用两种方法来实 现条件操作。在一个典型的应用中, x< y的结果非常地不可预测,因此即使是最精密的 分支预测硬件也只能有大约50%的概率猜对。此外,两个代码序列中的计算执行都只需要 一个时钟周期。因此,分支预测错误处罚主导着这个函数的性能。对于包含条件跳转的 x86-64代码,我们发现当分支行为模式很容易预测时,每次调用函数需要大约8个时钟周 期;而分支行为模式是随机的时候,每次调用需要大约17.50个时钟周期。由此我们可以 推断出分支预测错误的处罚是大约19个时钟周期。这就意味着函数需要的时间范围大约 在8到27个周期之间,这依赖于分支预测是否正确。



![image-20210502183032225](深入理解计算机系统.assets/image-20210502183032225.png)

图3一⊥8列举了x86-64上一些可用的条件传送指指令。每条指令都有两个操作数:源寄 存器或者内存地址S,和目的寄存器R.与不同的SET(3.6.2节)和跳转指令(3.6.3节) 一样,这些指令的结果取决于条件码的值。源值可以从内存或者源寄存器中读取,但是只 有在指定的条件满足时,才会被复制到目的寄存器中。

**源和目的的值可以是16位、 32位或64位**长。不支持单字节的条件传送.无条件指令的操 作数的长度显式地编码在指令名中(例如m〇w和movl).,**汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度,所以对所有的操作数长度,都可以使用同一个的指令名字**。

同条件跳转不同,**处理器无需预测测试的结果就可以执行条件传送**。处理器只是读源 值(可能是从内存中),检查条件码,然后要么更新目的寄存器,要么保持不变。**我们会在 第4章中探讨条件传送的实现**。

为了**理解如何通过条件数据传输来实现条件操作**,考虑下面的条件表达式和赋值的通 用形式:

**v = test-expr ? then-expr :else -expr;**

用条件控制转移的标准方法来编译这个表达式会得到如下形式:

```
if(!test-expr)

​	goto false;

v = then-expr;

​	foto done;

false:

​	v = else-expr;

done:
```

这段代码包含两个代码序列:一个是对else-expr求值,另一个对then-expr求值。条件 跳转和无条件跳转结合起来使用是为了保证只有一个序列执行。

**基于条件传送的代码,会对两个序列都求值**,最终值的选择基于对test-expr的求值。可以用下面的抽象代码描述:

v = then-expr;

ve = else-expr;

t = test-expr;

if(!t)

v = ve;

**不是所有的条件表达式都可以用条件传送来编译。**最重要的是,无论测试结果如何,我们给出的抽象代码会对两个序列都求值。如**果这两个表达式中的任意一个 可能产生错误条件或者副作用,就会导致非法的行为**。前面的一个例子(图3-16)就是这种 情况。

实际上,我们在该例中引人副作用就是为了**强制GCC用条件转移来实现这个函数**。

作为说明,考虑下面这个C函数

![image-20210502190123741](深入理解计算机系统.assets/image-20210502190123741.png)

乍一看,这段代码似乎很适合被编译成使用条件传送,当指针为空时将结果设置为0, 如下面的汇编代码所示:

![image-20210502190142703](深入理解计算机系统.assets/image-20210502190142703.png)

不过,这个实现是非法的,因为即使当测试为假时, m〇vq指令(第2行)对xp的间接引用 还是发生了,**导致一个间接引用空指针的错误。**所以,必须**用分支代码来编译这段代码**

使用条件传送也不总是会提高代码的效率。例如如,如果两个序列值需要大量的计算,那么当相对应的条件不满足时,这些工作就白费了。编译器必须考虑 浪费的计算和由于分支预测错误所造成的性能处罚之间的相对性能。说实话,编译器并不 具有足够的信息来做出可靠的决定;例如,它们不知道分支会多好地遵循可预测的模式。我们对GCC的实验表明,只有当两个表达式都很容易计算时,例如表达式分别都只是一 条加法指令,它才会使用条件传送。根据我们的经验,即使许多分支预测错误的开销会超 过更复杂的计算, **GCC还是会使用条件控制转移**。

所以,总的来说,条件数据传送提供了一种用条件控制转移来实现条件操作的替代策 略。它们只能用于非常受限制的情况,但是这些情况还是相当常见的,而且与现代处理器 的运行方式更契合。



#### 3.6.7 循环

C语言提供了多种循环结构,即do-While、 While和for。汇编中没有相应的指令 存在,可以用条件测试和跳转组合起来实现循环的效果。GCC和其他汇编器产生的循环 代码主要基于两种基本的循环模式。我们会循序渐进地研究循环的翻译,从d〇一While开 始,然后再研究具有更复杂实现的循环,并覆盖这两种模式。

##### 1.do-while

```
do

	body-statement

	while(test-expr)
```

这个循环的效果就是重复执行60dy蛔比仍钟砧,对‘“十“卸一求值,如果求值的结果为非零,就继续循环。可以看到,body至少会执行一次

这种通用形式可以被翻译成如下所示的条件和g〇t〇语句:

```
loop:
	body-statement
	t = test-expr
	if(t)
		goto loop;
```

也就是说,每次循环,程序会执行循环体里的语旬,然后执行测试表达式。如果测试为 真,就回去再执行一次循环。

看一个示例,图3-19a给出了一个函数的实现,用d〇-While循环来计算函数参数的 阶乘,写作n!。这个函数只计算″>0时″的阶乘的值。



##### 逆向工程循环

理解产生的汇编代码与原始源代码之间的关系,关键是找到程序值和寄存器之间的 映射关系。对于图3-19的循环来说,这个任务非常简单,但是对于更复杂的程序来说, 就可能是更具挑战性的任务o C语言编译器常常会重组计算,因此有些C代码中的变量 在机器代码中没有对应的值;而有时,机器代码中又会引入源代码中不存在的新值。此 外,编译器还常常试图将多个程序值映射到一个寄存器上,来最小化寄存器的使用率。我们描述fact_do的过程对于逆向工程循环来说,是一个通用的策略看看在循 环之前如何初始化寄存器,在循环中如何更新和测试寄存器,以及在循环之后又如何使 用寄存器。这些步骤中的每一步都提供了一个线索,组合起来就可以解开谜团。做好准备,你会看到令人惊奇的变换,其中有些情况很明显是编译器能够优化代码,而有些情 况很难解释编译器为什么要选用那些奇怪的策略。**根据我们的经验, GCC常常做的一 些变换,非但不能带来性能好处,反而甚至可能降低代码性能.**

##### 2.while循环

与d〇一While的不同之处在于,在第一次执行body-statement之前,它会对test-eXpr求 值,循环有可能就中止了。有很多种方法将while循环翻译成机器代码, GCC在代码生 成中使用其中的两种方法。这这两种方法使用同样的循环结构,**与d〇一While一样,**不过它 们实现初始测试的方法不同。

**第一种翻译方法,**我们称之为跳转到中间(jumptomiddle),它执行一个无条件跳转 跳到循环结尾处的测试,以此来执行初始的测试。可以用以下模板来表达这种方法,这个 模板把通用的while循环格式翻译到g〇tO代码:

```
	goto test:
loop:
	body-statement
test:
	t = test-expr
	if(t)
		goto loop;
```

第二种翻译方法,我们称之为guarded-do,首先用条件分支,如果初始条件不成立就 跳过循环,把代码变换为do-While循环。当使用较高优化等级编译时,例如使用命令行 选项一01, GCC会采用这种策略略。可以用如下模板来表达这种方法,把通用的while循环格式翻译成do-While循环:

![image-20210505173427524](深入理解计算机系统.assets/image-20210505173427524.png)	

利用这种实现策略,编译器常常可**以优化初始的测试**,例如认为测试条件总是满足。



##### 3.for循环

C语言标准说明(有一个例外,练习题3.29中有特别说明),这样一个循环的行为与下面 这段使用while循环的代码的行为一样:

![](深入理解计算机系统.assets/image-20210505181020086.png)	

程序首先对初始表达式加十g工卸一求值,然后进人循环;;在循环中它先对测试条件‘“‘ 飞工〆求值,,如果测试结果为“假”就会退出,否则执行循环体切dy飞‘仇〃″名″年 最后对 更新表达式昨加灰广“夕r求值o

GCC为f〇r循环产生的代码是while循环的两种翻译之一,这取决于优化的等级。 也就是,跳转到中间策略会得到如下g〇tO代码‥

作为一个示例,考虑用f〇r循环写的阶乘函数:

![](深入理解计算机系统.assets/image-20210505181220705.png)	

如上述代码所示,用for循环编写阶乘函数最自然的方式就是将从2一直到″的因子 乘起来,因此,这个函数与我们使用while或者do-While循环的代码很不一样。	

这段代码中的for循环的不同组成部分如下‥

![image-20210505181426771](深入理解计算机系统.assets/image-20210505181426771.png)	

用这些部分替换前面给出的模板中相应的位置,就把for循环转换成了while循环, 得到下面的代码‥

![image-20210505181508110](深入理解计算机系统.assets/image-20210505181508110.png)	

对while循环进行跳转到中间变换,得到如下goto代码:

![	](深入理解计算机系统.assets/image-20210505181557613.png)	

确实,仔细查看使用命令行选项」Og的GCC产生的汇编代码,会发现它非常接近于以下模板‥

综上所述, C语言中三种形式的所有的循环一d〇一While、 While和f〇r一都可以 用一种简单的策略来翻译,产生包含一个或多个条件分支的代码。控制的条件转移提供了 将循环翻译成机器代码的基本机制。



#### 3.6.8 switch语句

switch(开关)语句可以根据一个整数索引值进行多重分支(multiway branching)。在处理具有多种可能结果的测试时,这种语句特别有用。它们不仅提高了C代码的可读性, 而且通过使用跳转表(jump table)这种数据结构使得实现更加高效。跳转表是一个数组,表项i是一个代码段的地址,这个代码段实现当开关索引值等于i时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用,确定跳转指令的目标。和使用一 组很长的if-else语旬相比,使用跳转表的优点是执行开关语句的时间与开关情况的数 量无关o GCC根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情 况数量比较多(例如4个以上),并且值的范围跨度比较小时,就会便用跳转表。

![image-20210506190528334](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210506190528334.png)	

图3-22a是一个C语言switch语旬的示例。这个例子有些非常有意思的特征,包括 情况标号(case label)跨过一个不连续的区域(对于情况101和105没有标号,有些情况有 多个标号(情况104和106),而有些情况则会落人其他情况之中(情况102),因为对应该 情况的代码段没有以break语旬结尾。图3-23是编译switch_eg时产生的汇编代码。这段代码的行为用C语言来描述就是 图3-22b中的过程switch eg implo这段代码使用了GCC提供的对跳转表的支持,这是对C语言的扩展。数组jt包含7个表项,每个都是一个代码块的地址。**这些位置由代码 中的标号定义,在jt的表项中由代码指针指明,由标号加上‘&&’前缀组成。**  (回想运算符 &创建一个指向数据值的指针。在做这个扩展时, GCC的作者们创造了一个新的运算符 **&&,这个运算符创建一个指向代码位置的指针**。)建议你研究一下C语言过程switch_eg_ impl,以及它与汇编代码版本之间的关系。

原始的C代码有针对值100、 102-104和106的情况,但是开关变量n可以是任意整数。。编 译器首先将n减去100,把取值范围移到0和6之间,创建一个新的程序变量,在我们的C版 本中称为index。**补码表示的负数会映射成无符号表示的大正数,利用这一事实,将index看 作无符号值,从而进一步简化了分支的可能性**。**因此可以通过测试index是否大于6来判定 index是否在0-6的范围**之外。在C和汇编代码中,根据index的值,有五个不同的跳转位置: locLA(在汇编代码中标识为.L3), loc_B(.L5), loc_C(.L6), loc_D(.L7)和l〇C_def (.L8),最后一个是默认的目的地址。每个标号都标识一个实现某个情况分支的代码块在C 和汇编代码中,程序都是将index和6做比较,如果大于6就跳转到默认的代码处。

##### gcc独有语法(跳转表)

```
  1 #include <stdio.h>
  2 #include <stdlib.h>
  3 #include <string.h>
  4 
  5 
  6 int main(int argc, char* argv[])
  7 {
  8     int index = atoi(argv[1]);
  9 
 10 
 11     int *a[2] = {&&L1, &&L2};
 12 
 13 
 14     if(index > 8)
 15         goto *a[0];
 16         goto *a[1];
 17 
 18 L2:
 19     printf("index <= 8\n");
 20     return 0;
 21 
 22 L1:
 23     printf("index > 8\n");
 24     return 0;
 25 }

```



### 3.7 过程

过程是软件中一种很重要的抽象。它提供了一种封装代码的方式用一组指定的参数和一个可 选的返回值实现了某种功能.然后,可以在程序中不同的地方调用这个函数。设计良好的软件用过程 作为抽象机制,隐藏某个行为的具体实现,同时又提供清晰简洁的接日定义,说明要计算的是哪些 值,过程会对程序状态产生什么样的影响。不同编程语言中,过程的形式多样:函数(fnction),方 法(method) ,子例程(subroutine) ,处理函数(handler)等等,但是它们有一些共有的特性。

要提供对过程的机器级支持,必须要处理许多不同的属性。为了讨论方便,假设过程 P调用过程Q, Q执行后返回到po 这些动作包括下面一个或多个机制:

​	**传递控制**。在进人过程Q的时候,程序计数器必须被设置为Q的代码的起始地址,然 后在返回时,要把程序计数器设置为p中调用Q后面那条指令的地址。

​	**传递数据**。 p必须能够向Q提供一个或多个参数, Q必须能够向p返回一个值。

​	**分配和释放内存**。在开始时, Q可能需要为局部变量分配空间,而在返回前,又必须 释放这些存储空间o

x86-64的过程实现包括一组特殊的指令和一些对机器资源(例如寄存器和程序内存)使 用的约定规则。人们花了大量的力气来尽量减少过程调用的开销。所以,它遵循了被认为 是最低要求策略的方洼,只实现上述机制中每个过程所必需的那些。接下来,我们一步步 地构建起不同的机制,先描述控制,再描述数据传递,最后是内存管理。

#### 3.7.1 运行时栈

C语言过程调用机制的一个关键特性(大多数 其他语言也是如此)在于使用了栈数据结构提供的 后进先出的内存管理原则。在过程P调用过程Q 的例子中,可以看到当Q在执行时, P以及所有 在向上追溯到p的调用链中的过程,都是**暂时被 挂起的**当Q运行时,它只需要为局部变量分配 新的存储空间,或者设置到另一个过程的调用。另一方面,当Q返回时,任何它所分配的局部存 储空间都可以被释放。因此,程序可以用栈来管 理它的过程所需要的存储空间,栈和程序寄存器 存放着传递控制和数据、分配内存所需要的信息。当P调用Q时,控制和数据信息添加到栈尾。当p 返回时,这些信息会释放掉

如3.4.4节中讲过的, x86-64的栈向低地 址方向增长,而栈指针宅rsp指向栈顶元素。可 以用pushq和popq指令将数据存人栈中或是 从栈中取出。将栈指针减小一个适当的量可以 为没有指定初始值的数据在栈上分配空间。类 似地,可以通过增加栈指针来释放空间.

**当x86-64过程需要的存储空间超出寄存器 能够存放的大小时**,就会在栈上分配空间。这 个部分称为过程的栈帧(stack fram)。图3-25给出了运行时栈的通用结构,包括把它划分为栈帧。当前正在执行的过程的帧总是在栈 顶。当过程P调用过程Q时,会把返回地址压人栈中,指明当Q返回时,要从p程序的哪 个位置继续执行。我们把这个返回地址当做p的栈帧的一部分,因为它存放的是与P相关 的状态o Q的代码会扩展当前栈的边界,分配它的栈帧所需的空间。在这个空间中,它可 以保存寄存器的值,分配局部变量空间,为它调用的过程设置参数。大多数过程的栈帧都 是定长的,在过程的开始就分配好了。但是有些过程需要**变长的帧,**这**个问题会在3.10.5 节中讨论**。通**过寄存器,过程P可以传递最多6个整数值(也就是指针和整数),但是如果 Q需要更多的参数, P可以在调用Q之前在自已的栈帧里存储好这些参数。**

为了提高空间和时间效率, x86-64过程只分配自已所需要的栈帧部分。例如,许多过 程有6个或者更少的参数,那么所有的参数都可以通过寄存器传递。因此,图3-25中画 出的某些栈帧部分可以省略。实际上,许多函数甚至根本不需要栈帧。当所有的局部变量 都可以保存在寄存器中,而且该函数不会调用任何其他函数(有时称之为叶子过程,此时 把过程调用看做树结构)时,就可以这样处理。例如,**到目前为止我们仔细审视过的所有 函数都不需要栈帧**.

#### 3.7.2 转移控制

将控制从函数p转移到函数Q只需要简单地把程序计数器(PC)设置为Q的代码的起始位 置。不过,当稍后从Q返回的时候,处理器必须记录好它需要继续P的执行的代码位置。在 x86-64机器中,这个信息是用指令call Q调用过程Q来记录的。该指令会把地址A压人栈 中,并将PC设置为Q的起始地址。压人的地址A被称为返回地址,是紧跟在call指令后 面的那条指令的地址。对对应的指令ret会从栈中弹出地址A,并把PC设置为Ao

下表给出的是call和ret指令的一般形式:

![image-20210508122518140](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210508122518140.png)	

(这些指令在程序OBJDUMP产生的反汇编输出中被称为callq和retqo添加的后缀‘q’ 只是为了强调这些是x86-64版本的调用和返回,而不是IA32的。在x86-64汇编代码中, 这两种版本可以互换。)

call指令有一个目标,即指明被调用过程起始的指令地址。同跳转一样,调用可以 是直接的,也可以是间接的。在汇编代码中,直接调用的目标是一个标号,而间接调用的 目标是Ⅹ后面跟一个操作数指示符,使用的是图3-3中描述的格式之一。

图3-26说明了3.2.2节中介绍的multstore和main函数的call和ret指令的执行 情况。下面是这两个函数的反汇编代码的节选:

可以看到,这种把返回地址压人栈的简单的机制能够让函数在稍后返回到程序中正确 的点o C语言(以及大多数程序语言)标准的调用/返回机制刚好与栈提供的后进先出的内 存管理方法吻合。

**call 指令执行后将下一条指令的地址压栈(%rsp - 8),PC跳转到call后的地址。**

**ret 指令执行后出栈(%rsp + 8)到PC**

#### 3.7.3 数据传送

当调用一个过程时,除了要把控制传递给它并在过程返回时再传递回来之外,过程调 用还可能包括把数据作为参数传递,而从过程返回还有可能包括返回一个值o x86-64中, **大部分过程间的数据传送是通过寄存器实现的**。例如,我们已经看到无数的函数示例,参 数在寄存器%rdi、%rsi和其他寄存器中传递。当过程P调用过程Q时, P的代码必须首先 把参数复制到适当的寄存器中。类似地,当Q返回到p时, P的代码可以访问寄存器%rax 中的返回值。在本节中,我们更详细地探讨这些规则。



![image-20210517152238801](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210517152238801.png)	

**x86-64中,可以通过寄存器最多传递6个整型(例如整数和指针)参数**。寄存器的使用 是有特殊顺序的,寄存器使用的名字取决于要传递的数据类型的大小,如图3-28所示。会根据参数在参数列表中的顺序为它们分配寄存器。可以通过64位寄存器适当的部分访 问小于64位的参数。例如,如果第一个参数是32位的,那么可以用笔edi来访问它。

![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210517153258712.png)	

**如果一个函数有大于6个整型参数,超出6个的部分就要通过栈来传递。**假设过程P 调用过程Q,有″个整型参数,且″>60。那么P的代码分配的栈帧必须要能容纳7到″ 号参数的存储空间,如图3-25所示。

**通过栈传递参数时,所有的数据大小都向8的倍数对齐。**参 数到位以后,程序就可以执行call指令将控制转移到过程Q了。过程Q可以通过寄存器 访问参数,有必要的话也可以通过栈访问。相应地,如果Q也调用了某个有超过6个参数 的函数,它也需要在自已的栈帧中为超出6个部分的参数分配空间,如图3-25中标号为 “**参数构造区”**的区域所示。

作为参数传递的示例,考虑图3-29a所示的C函数proc。这个函数有8个参数,包括 字节数不同的整数(8、 4、 2和1)和不同类型的指针,每个都是8字节的。

![image-20210517160725456](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210517160725456.png)	

#### 3.7.4 栈上的局部存储

到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不 过有些时候,局部数据必须存放在内存中,常见的情况包括:

●寄存器不足够存放所有的本地数据。

●对一个局部变量使用地址运算符‘&’,因此必须能够为它产生一个地址

●某些局部变量是数组或结构,因此必须能够通过数组或结构引用被访问到。在描述 数组和结构分配时,我们会讨论这个间题。

一般来说,过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分,标 号为“局部变量”,如图3-25所示。

**来看一个处理地址运算符的例子,**图3-31a中给出的两个函数。函数swap_add交换 指针xp和yp指向的两个值,并返回这两个值的和。函数caller创建到局部变量argl 和arg2的指针,把它们传递给swap_add。**图3-31b展示了caller是如何用栈帧来实现 这些局部变量的o** 

![image-20210518124057934](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210518124057934.png)	

 caller的代码开始的时候把栈指针减掉了16;实际上这就是在栈上分 配了16个字节o S表示栈指针的值,可以看到这段代码计算&arg2为S+8(第5行),而 &argl为So 因此可以推断局部变量argl和arg2存放在栈帧中相对于栈指针偏移量为0 和8的地方。当对swap_add的调用完成后, Ca||er的代码会从栈上取出这两个值(第 8-9行),计算它们的差,再乘以swap_add在寄存器frax中返回的值(第10行)。最后, 该函数把栈指针加16,释放栈帧(第11行)。通过这个例子可以看到,**运行时栈**提供了**一 种简单的、在需要时分配、函数完成时释放局部存储的机制**。

#### 3.7.5 寄存器中的局部存储空间

**寄存器组是唯一被所有过程共享的资源。**虽然在给定时刻只有一个过程是活动的,我们仍然必须确保当一个过程(调用者)调用另一 个过程(被调用者)时,**被调用者不会覆盖调用者稍后会使用的寄存器值。**为此 x**86-64采 用了一组统一的寄存器使用惯例**,**所有的过程(包括程序库)都必须遵循**。

根据惯例,寄存器%**rbx、%rbp**和**%r12-%r15**被划分为**被调用者保存寄存器**.当过程P 调用过程Q时, Q必须保存这些寄存器的值,保证它们的值在Q返回到p时与Q被调用时 是一样的。过程Q保存一个寄存器的值不变,要么就是**根本不去改变它**,要么**就是把原始 值压人栈中,改变寄存器的值,然后在返回前从栈中弹出旧值**。压人寄存器的值会在栈帧 中创建标号为“保存的寄存器”的一部分,如图3-25中所示。有有了这条惯例, P的代码就 能安全地把值存在被调用者保存寄存器中(当然,要先把之前的值保存到栈上),调用Q, 然后继续使用寄存器中的值,不用担心值被破坏。

**所有其他的寄存器,除了栈指针持sp,都分类为调用者保存寄存器**.这就意味着任何 函数都能修玫它们。可以这样来理解“调用者保存”这个名字:过程P在某个此类寄存器 中有局部数据,然后调用过程Qo 因为Q可以随意修玫这个寄存器,所以在调用之前首先 保存好这个数据是P(调用者)的责任.

#### 3.7.6 递归过程

前面已经描述的**寄存器**和**栈的惯例**使得**x86-64过程**能够**递归地调用它们自身**。每个 过程调用在栈中都有它自已的私有空间,因此多个未完成调用的局部变量不会相互影响。此外,栈的原则很自然地就提供了适当的策略,当过程被调用时分配局部存储,当返回时 释放存储。

从这个例子我们可以看到**,递归调用一个函数本身与调用其他函数是一样的**。栈规则 提供了一种机制,每次函数调用都有它自已私有的状态信息(保存的返回位置和被调用者 保存寄存器的值)存储空间。。如果需要,它还可以提供局部变量的存储。栈分配和释放的规则很自然地就与函数调用一返回的顺序匹配。这种实现函数调用和返回的方法甚至对更 复杂的情况也适用,包括相互递归调用(例如,过程P调用Q, Q再调用P)。

### 3.8 数组分配和访问

C语言中的数组是一种将标量数据聚集成更大数据类型的方式。 C语言实现数组的方式 非常简单,因此很容易翻译成机器代码o  C语言的一个不同寻常的特点是可以产生指向数组 中元素的指针,并对这些指针进行运算。在机器代码中,这些指针会被翻译成地址计算。

优化编译器非常善于简化数组索引所使用的地址计算。不过这使得C代码和它到机器 代码的翻译之间的对应关系有些难以理解0

#### 3.8.1 基本原则

对于数据类型丁和整型常数N,声明如下:

T A[N];

起始位置表示为XA.

这个声明有两个效果。首先,它在内存中分配一个L●N字节的连续 区域,这里L是数据类型丁的大小(单位为字节)。其次,它引人了标识符A,可以用A来 作为指向数组开头的指针,这个指针的值就是工Ao可以用0-N-1的整数索引来访间该数 组元素。数组元素;会被存放在地址为工A+L上的地方。

x86-64的内存引用指令可以用来简化数组访问。例如,假设E是一个int型的数组,而我们想计算E[i],在此, **E的地址存放在寄存器%rdx中**,而**i存放在寄存器%rcx中**。 然后,指令

**movl (%rdx,%rcx,4) ,%eax**

**会执行地址计算,读这个内存位置的值,并将结果存放到寄存器老eax中。**允许的伸缩因子1、 2、 4和8覆盖了所有基本简单数据类型的大小。

#### 3.8.2 指针运算

C语言允许对指针进行运算,而计算出来的值会根据该指针引用的数据类型的大小进 行伸缩。也就是说,如果p是一个指向类型为丁的数据的指针, p的值为击,那么表达式 p+i的值为生+L上,这里L是数据类型丁的大小。

单操作数操作符‘&’和‘★ ’可以产生指针和间接引用指针。也就是,对于一个表示某 个对象的表达式Expr, &王xpr是给出该对象地址的一个指针。对于一个表示地址的表达 式AExpr, ★AExpr给出该地址处的值。因此,袁达式Expr与★ &互xpr是等价的

可以对 数组和指针应用数组下标操作。数组引用A[i]等同于表达式★ (A+ i)。它计算第士个数 组元素的地址,然后访问这个内存位置。

扩展一下前面的例子,假设整型数组E的起始地址和整数索引;分别存放在寄存器 ?rdx和?rcx中。下面是一些与E有关的表达式。我们还给出了每个表达式的汇编代码实 现,结果存放在寄存器宅eax(如果是数据)或寄存器宅rax(如果是指针)中。

![image-20210519132124054](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519132124054.png)

在这些例子中,可以看到返回数组值的操作类型为int,因此涉及4字节操作(例如 mov|)和寄存器(例如?eax)。那些返回指针的操作类型为int ★ ,因此涉及8字节操作 (例如Ieaq)和寄存器(例如宅rax)。最后一个例子表明可以计算同一个数据结构中的两个 指针之差,结果的数据类型为l〇ng,值等于两个地址之差除以该数据类型的大小。

#### 3.8 3 嵌套的数组

当我们创建数组的数组时,数组分配和引用的一般原则也是成立的。例如,声明

int A[5] [3];

等价于下面的声明

typedef int row3_t[3] ;

row3_t A[5] ;

数据类型r〇w3」被定义为一个3个整数的数组组。数组A包含5个这样的元素,每个元素 需要12个字节来存储3个整数。整个数组的大小就是4×5×3==60字节。

![image-20210519141425950](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519141425950.png)	

数组A还可以被看成一个5行3列的二维数组,用[0] [0]到A[4] [2]来引用。数组元素在内存中按照“行优先”的 顺序排列,意味着第O行的所有元素,可以写作A[0],后面 跟着第1行的所有元素(A[1]),ヽ以此类推,如图3-36所示。

这种排列顺序是嵌套声明的结果。。将A看作一个有5个 元素的数组,每个元素都是3个int的数组,首先是A[0], 然后是A[l],以此类推。

要访问多维数组的元素,编译器会以数组起始为基地址, (可能需要经过伸缩的)偏移量为索引,产生计算期望的元素 的偏移量,然后使用某种MOv指令。通常来说,对于一个 声明如下的数组:

T D[R] [C];

它的数组元素D[iⅡ]]的内存地址为

![image-20210519142507352](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519142507352.png)	

这里, L是数据类型丁以字节为单位的大小作为一个示例,考虑前面定义的5×3的整型数组Ao 假设工A、 Z和j分别在寄存器%rdi、%rsi和%rdx中。然后,可以用下面的代码将数组元素A[i] [j]正复制到寄存器宅eax中:

![image-20210519143044846](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519143044846.png)	

正如可以看到的那样,这段代码计算元素的地址为生+12亡+4j…生+4(3;+j),使用了 x86-64地址运算的伸缩和加法特性

#### 3.8.4 定长数组

C语言编译器能够优化定长多维数组上的操作代码。这里我们展示优化等级设置为01时GCC采用的一些优化。假假设我们用如下方式将数据类型fix_matrix声明为16×16 的整型数组:

![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519145339846.png)	

![image-20210519145534171](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519145534171.png)

(这个例子说明了一个很好的编码习惯。。当程序要用一个常数作为数组的维度或者缓冲区 的大小时,最好通过# define声明将这个常数与一个名字联系起来,然后在后面一直使 用这个名字代替常数的数值。这样一来,如果需要修改这个值,只用简单地修玫这个# define声明就可以了。)图3-37a中的代码计算矩阵A和B乘积的元素Z,居,即A的行;和 B的列居的内积o  **GCC产生的代码(我们再反汇编成C),**如图3-37b中函数fix_Pr〇d ele_OPt所

![image-20210519145725904](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519145725904.png)

#### **3.8.5 变长数组**

历史上, C语言只支持大小在编译时就能确定的多维数组(对第一维可能有些例外)。程序员需要变长数组时不得不用malloc或calloc这样的函数为这些数组分配存储空间,而 且不得不显式地编码,用行优先索引将多维数组映射到一维数组,如公式(3. 1)所示。 **ISO C99引人了一种功能**,**允许数组的维度是表达式,****在数组被分配的时候才计算出来**。

在变长数组的C版本中,我们可以将一个数组声明如下:

![image-20210519150813908](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519150813908.png)	

它可以作为一个局部变量,也可以作为一个函数的参数,然后在遇到这个声明的时候,通 过对表达式“卸一1和∞〆2求值来确定数组的维度因此,例如要访问乃×″数组的元素 上j,我们可以写一个如下的函数:

![image-20210519150924116](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519150924116.png)

**参数n必须在参数A[n] [n]之前**,这样函数就可以在遇到这个数组的时候计算出数组的维度.

GCC为这个引用函数产生的代码如下所示:

![image-20210519151444747](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519151444747.png)

##### 3.8.5.1定长数组与变长数组的不同点

1.由于增加了参数 即 寄存器的使用变化了; 

2.)用了乘法指令来计算n×i，而不是用Ieaq指令来计 算3×i;

。因此引用变长数组只需要对定长数组做一点儿概括。动态的版本必须用乘法指令对 主伸缩″倍,而不能用一系列的移位和加法在一些处理器中,乘法会招致严重的性能处 罚,但是在这种情况中无可避免。

在一个循环中引用变长数组时,编译器常常可以利用访问模式的规律性来优化索引的 计算。

我们看到程序既使用了伸缩过的值4″(寄存器持9)来增加Bptr,也使用了″的值(寄 存器%rdi)来检查循环的边界o C代码中并没有体现出需要这两个值,但是由于指针运算 的伸缩,才使用了这两个值。 **可以看到,如果允许使用优化, GCC能够识别出程序访间多维数组的元素的步长**。 然后生成的代码会避免直接应用等式(3. 1)会导致的乘法。不论生成基于指针的代码(图3- 37b)还是基于数组的代码(图3-38b),这**些优化都能显著提高程序的性能**0



### 3.9 异质的数据结构

C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制:结构(structure),用关键字struct来声明,将多个对象集合到一个单位中;联合(union),用关键 字union来声明,允许用几种不同的类型来引用一个对象.

#### 3.9.1结构

C语言的struct声明创建一个数据类型,将可能不同类型的对象聚合到一个对象中。用名字来引用结构的备个组成部分。类似于数组的实现,结构的所有组成部分都存放在内 存中一段连续的区域内,而指向结构的指针就是结构第一个字节的地址编**译器维护关于 每个结构类型的信息,指示每个字段(field)的字节偏移。它以这些偏移作为内存引用指令 中的位移,从而产生对结构元素的引用。**

##### 3.9.1.2 成员引用符号的优先级高于*

![image-20210519153110833](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210519153110833.png)

综上所述,结构的各个字段的选取完全是在编译时处理的。机**器代码不包含关于字段 声明或字段名字的信息**。



#### 3.9.2 联合

**联合提供了一种方式,能够规避C语言的类型系统,允许以多种类型来引用一个对 象**。联合声明的语法与结构的语法一样,只不过语义相差比较大。**它们是用不同的字段来 引用相同的内存块。**

考虑下面的声明‥

![image-20210520133224309](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210520133224309.png)	

![image-20210520133437588](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210520133437588.png)	

1.当一个结构体内的字段是互斥的，使用联合节省空间。

2.用来访问不同数据类型的位模式



##### 3.9.2.1 此题可深入理解mov的用法

![image-20210520170649471](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210520170649471.png)	![image-20210520170753519](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210520170753519.png)	



#### 3.9.3 数据对齐

结构体嵌套结构体时，按照各自结构体的数据类型对齐



### 3.10 在机器级程序中将控制与数据结合起来

#### 3.10.1

&运算符的机器码实现通常用leaq指令来实现

函数指针的值是该函数机器代码表示中第一条指令的地址

##### 3.1.10.1 函数指针

![image-20210525184159265](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210525184159265.png)		



#### 3.10.2 应用： 使用gdb调试器

![image-20210602124540173](深入理解计算机系统.assets/image-20210602124540173.png)	

#### 3.10.3 内存越界引用和缓冲区溢出

#### 3.10.4 对抗缓冲区溢出攻击

1.栈随机化

2.栈破坏检测

3.限制可执行代码区域

#### 3.10.5 支持变长栈帧

![image-20210602145212106](深入理解计算机系统.assets/image-20210602145212106.png)	

**将rax的值向下舍如为16的倍数**



### 3.11 浮点代码

![image-20210602150244889](深入理解计算机系统.assets/image-20210602150244889.png)	

#### 浮点数据传送指令

处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：

1. 如何存储和访问浮现数值。通常是通过某种寄存器方式来访问。
2. 对浮点数据操作的指令
3. 向函数传递浮现数参数和从函数返回浮点数结果的规则
4. 函数调用过程中保存寄存器的规则——例如，一些寄存器被指定为调用者保存，而其它的被指定为被调用者保存。



​	每个**YMM寄存器**可以存放八个32位值，或四个64位值，这些值可以是整数，也可以是浮点数。



标量数据

![](深入理解计算机系统.assets/image-20210603133104574.png)	



![image-20210603133827070](深入理解计算机系统.assets/image-20210603133827070.png)	



![](深入理解计算机系统.assets/image-20210603133705502.png)	



#### YMM寄存器

![image-20210603133950153](深入理解计算机系统.assets/image-20210603133950153.png)	



![image-20210603125359218](深入理解计算机系统.assets/image-20210603125359218.png)	



![image-20210603125720729](深入理解计算机系统.assets/image-20210603125720729.png)	

![image-20210603125733398](深入理解计算机系统.assets/image-20210603125733398.png)	

![image-20210603125753354](深入理解计算机系统.assets/image-20210603125753354.png)	

![image-20210603125804702](深入理解计算机系统.assets/image-20210603125804702.png)	

#### 3.11.1 浮点传送和转换操作

