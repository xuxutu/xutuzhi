# 深入理解计算机系统

## 第三章 程序的机器级表示

### 3.2.2 代码实例 

### 3.2.2.1如何展示程序的字节表示

![image-20210401132037611](/home/zhaoyong/.config/Typora/typora-user-images/image-20210401132037611.png)	

### 3.2.2.2查看机器代码文件内容的反汇编器

![image-20210401132414628](/home/zhaoyong/.config/Typora/typora-user-images/image-20210401132414628.png)	



![image-20210412124217910](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210412124217910.png)	



### 3.2.2.3 访问机器的低级特性

1.使用汇编代码写整个函数

2.利用GCC的支持，直接在c程序中嵌入汇编代码

#### 3.2.2.3.1 intel 汇编的生成

```
gcc -Og -S -masm=intel mstore.c
```

![image-20210412130813832](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210412130813832.png)	

#### 3.2.2.3.2 C语言访问不到的低级特性

**虽然C编译器在把程序中表达的计算转换到机器代码方面表现出色**，但是仍然有一 些机器特性是C程序访问不到的。例如，每次x86-64处理器执行算术或逻辑运算时,如果得到的运算结果的**低8位中有偶数个l,**那么就会把一个名为PF的1位条件码 (conditioncode)标志设置为1,否则就设置为0。这里的PF表示“parity flag(奇偶标 志)″。在c语言中计算这个信息需要至少7次移位、掩码和异或运算(参见习题2.65)。即使作为每次算术或逻辑运算的一部分,硬件都完成了这项计算,而C程序却无法知道 PF条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。

在C程序中插入汇编代码有两种方法。第一种是,我们可以编写完整的函数,放进 一个独立的汇编代码文件中,让汇编器和链接器把它和用C语言书写的代码合并起来。第二种方法是,我们可以使用GCC的内联汇编(inlineassembly)特性,用asm伪指令可 以在C程序中包舍简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。

当然,在C程序中包含汇缩代码使得这些代码与某类特殊的机器相关(例如x86- 64),所以只应该在想要的特性只能以此种方式才能访问到时才使用它。

![image-20210413131818767](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413131818767.png)	

### 3.3 数据格式

![image-20210413132513647](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413132513647.png)

如图所示,大多数GCC生成的汇编代码指令都有一个字符的后缀,表明操作数的大小。例如,数据传送指令有四个变种: moVb(传送字节)、 moVW(传送字)、 moVl(传送双 字)和movq(传送四字)。后缀‘l’用来表示双字,因为32位数被看成是“长字(long word)。)″。注意,**汇编代码也使用后缀‘l’来表示4字节整数和8字节双精度浮点数**。这不 会产生歧义,因为浮点数使用的是一组完全不同的指令和寄存器。



### 3.4 通用目的寄存器

一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。图3-2显示了这16个寄存器。它们的名字都以笔r 开头,不过后面还跟着一些不同的命名规则的名字,这是由于指令集历史演化造成的。最初的8086中有8个16位的寄存器,即图3-2中的%ax到%bp。每个寄存器都有特殊的用 途,它们的名字就反映了这些不同的用途。扩展到IA32架构时,这些寄存器也扩展成32 位寄存器,标号从%eax到%ebp。扩展到x86-64后,原来的8个寄存器扩展成64位,标 号从%rax到%rbpo除此之外,还增加了8个新的寄存器,它们的标号是按照新的命名规 则制定的,从宅r8到宅r15。

![image-20210413171237073](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413171237073.png)	

如图3-2中嵌套的方框标明的,指令可以对这16个寄存器的低位字节中存放的不同 大小的数据进行操作。字节级操作可以访问最低的字节, 16位操作可以访问最低的2个字 节, 32位操作可以访问最低的4个字节,而64位操作可以访问整个寄存器。

在后面的章节中,我们会展现很多**指令,复制和生成1字节、 2字节、 4字节和8字 节值**。当这些指令以寄存器作为目标时,对于生成小于8字节结果的指令,寄存器中剩下 的字节会怎么样,对此有两条规则:**生成1字节和2字节数字的指令会保持剩下的字节不 变**;生**成4字节数字的指令会把高位4个字节置为O。 后面这条规则是作为从IA32到 x86-64的扩展的一部分而采用的。**

就像图3-2右边的解释说明的那样,在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针持sp,用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外15个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是,有一组标准的编程规范控制着如何使用寄存器来**管理栈**、**传递函数参数**、从**函数的返 回值**,以及**存储局部和临时数据**。我们会在描述过程的实现时(特别是在3.7节中),讲述这些惯例。



#### 3.4.1操作数指示符

![image-20210413175144406](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413175144406.png)

大多数指令有一个或多个操作数(operand),指示出执行一个操作中要使用的源数据 值,以及放置结果的目的位置。X86-64支持多种操作数格式(参见图3-3)。源数据值可以以常数形式给出,或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此,各种不同的操作数的可能性被分为三种类型。第一种类型是**立即数**(immediate),用来表示常数值。在ATT格式的汇编代码中,立即数的书写方式是‘$’后面跟一个用标准C表示法表示的整数,比如, S-577或soxlFo 不同的指令允许的立即数值范围不同,汇编器会自动选择最紧凑的方式进行数值编码。

第二种类型是**寄存器**(register),它表示某个寄存器的内容, 16个寄存器的低位1字节、 2字节、 4字节或8字节中的一个作为操作数,这些字节数分别对应于8位、 16位、 32位或64位。在图3-3中,我们用符号ra来表示任意寄存器α,用引用R[ra]来表示它的值,这是将寄存器集合看成一个数组R,用寄存器标 识符作为索引。

第三类操作数是**内存引用**,它会根据计算出来的地址(通常称为有效地址)访问某个内 存位置。因为将内存看成一个很大的字节数组,我们用符号讥[Addr]表示对存储在内存 中从地址A拍r开始的6个字节值的引用。为了简便,我们通常省去下标b。

如图3-3所示,有多种不同的寻址模式,允许不同形式的内存引用。表中底部用语法 ′仍仍(ro, r., S)表示的是最常用的形式。这样的引用有四个组成部分:一个**立即数偏移Imm** 一个**基址寄存器**Rb,一个**变址寄存器**Ri和一个**比例因子s,**这里s必须是1、 2、 4或者8.基址和变址寄存器都必须是64位寄存器。有效地址被计算为Imm+R[rb]+R[ri].s。引 用数组元素时,会用到这种通用形式。其他形式都是这种通用形式的特殊情况,只是省略 了某些部分。正如我们将看到的,当引用数组和结构元素时,比较复杂的寻址模式是很有 用的。

#### 3.4.2 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用 性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功 能。我们会介绍多种不同的数据传送指令,它们或者源和目的类型不同,或者执行的转换 不同,或者具有的一些副作用不同。在我们的讲述中,把许多不同的指令划分成**指令类**, 每一类中的指令执行相同的操作,只不过操作数大小不同。

图3-4列出的是最简单形式的数据传送指令一MOv类。这些指令把数据从源位置 复制到目的位置,不做任何变化o MOV类由四条指令组成‥ moVb、 moVW、 moVl和 m°vqo这些指令都执行同样的操作;主要区别在于它们操作的数据大小不同:分别是1、 2、 4和8字节。

![image-20210413200658558](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413200658558.png)

源操作数指定的值是一个立即数,存储在寄存器中或者内存中。目的操作数指定一个 位置,要么是一个寄存器或者,要么是一个内存地址o x**86-64加了一条限制,**传送指令的 **两个操作数不能都指向内存位置**。将一个值从一个内存位置复制到另一个内存位置需要两 条指令一**第一条指令将源值加载到寄存器**中,第二条将**该寄存器值写人目的位置**。参考 图3-2,这些指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个,寄存器部分的大小必须与指令最后一个字符(‘b’, ‘w’, ‘l’或‘q’)指定的大小匹配。大多数情况 中, MOv指令只会更新目的操作数指定的那些寄存器字节或内存位置。造成这个例外的 原因是x86-64采用的惯例,**即任何为寄存器生成32位值的指令都会把该寄存器的高位部 分置成0。**

下面的MOv指令示例给出了源和目的类型的五种可能的组合。记住,第一个是源操 作数,第二个是目的操作数：

![image-20210413201143861](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210413201143861.png)

图3-4中记录的最后一条指令是处理64位立即数数据的。常规的m〇vq指令只能以袁 示为32位补码数字的立即数作为源操作数,然后把这个值符号扩展得到64位的值,放到 目的位置o **movabsq**指令能够以任意64位立即数值作为源操作数,并且只能以寄存器作 为目的。

![image-20210414130240628](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210414130240628.png)

图3-5和图3-6记录的是两类数据移动指令,在将较小的源值复制到较大的目的时使 用。所有这些指令都把数据从源(在寄存器或内存中)复制到目的寄存器。MOvZ类中的 指令把目的中剩余的字节填充为0,而MOvS类中的指令通过符号扩展来填充,把源操作 的最高位进行复制。可以观察到,每条指令名字的最后两个字符都是大小指示符:第一个 字符指定源的大小,而第二个指明目的的大小。正如看到的那样,这两个类中每个都有三 条指令,包括了所有的源大小为1个和2个字节、目的大小为2个和4个的情况,当然只 考虑目的大于源的情况。

##### 3.4.2.1理解数据传送如何改变目的寄存器

正如我们描述的那样,关于数据传送指令是否以及如何修改目的寄存器的高位字节 有两种不同的方法。下面这段代码序列会说明其差别: 

![image-20210414131252753](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210414131252753.png)

在接下来的讨论中,我们使用十六进制表示。在这个例子中,第1行的指令把寄存器宅 rax初始化为位模式00112233445566770 剩下的指令的源操作数值是立即数值一10 回想一 1的十六进制表示形如FF…F,这里F的数量是表述中字节数量的两倍。因此m°vb指令 (第2行)把扯ax的低位字节设置为FF,而mow指令(第3行)把低2位字节设置为FFFF, 剩下的字节保持不变. movl指令(第4行)将低4个字节设置为FFFFFFFF,同时把高位4 字节设置为000000000最后m°vq指令(第5行)把整个寄存器设置为FFFFFFFFFFFFFFFF.

注意图3-5中并没有一条明确的指令**把4字节源值零扩展到8字节目的**。这样的指令 逻辑上应该被命名为movzlq,但是并没有这样的指令.。不过,这样的数据传送可以用以 寄存器为目的的movl指令来实现.现。这一**投术利用的属性是******,生成4字节值并以寄存器作 为目的的指令会把高4字节置为0。***

对于64位的目标,**所有三种源类型都有对应的符号扩 展传送,而只有两种较小的源类型有零扩展传送**。

图3-6还给出cltq指令。这条指令没有操作数:它总是以寄存器?eax作为源,frax作 为符号扩展结果的目的。它的效果与指令m〇VSlq %eax,frax完全一致,不过编码更紧凑。

**x86-64中的内存引用总是用四字长寄存器给出**

##### 3.4.2.2 mov指令常见错误

![image-20210414194441242](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210414194441242.png)

#### 3.4.3 数据传送示例

```
   3 long exchange(long* xp, long y)
  4 {
  5     long x = *xp;
  6     *xp = y;
  7     return x;
  8 }
 
 9 exchange:
 10     movq    (%rdi), %rax
 11     movq    %rsi, (%rdi)
 12     ret
```

如图3-7b所示,函数exchange由三条指令实现:两个数据传送(movq),加上一条返回函数被调用点的指令(ret)。我们会在3.7节中讲述函数调用和返回的细节。在此之前,**知道参数通过寄存器传递给函数就足够**了。我们对汇编代码添加注释来加以说明。**函数通过把值存储在寄存器宅rax或该寄存器的某个低位部分中返回**。

当过程开始执行时,过程参数xp和y分别存储在寄存器%rdi和%rsi中。然后,指 令2从内存中读出x,把它存放到寄存器宅rax中,直接实现了C程序中的操作x=★xpo稍 后,用寄存器持ax从这个函数返回一个值,因而返回值就是xo指令3将y写人到寄存 器%rdi中的xp指向的内存位置,直接实现了操作★xp=yo这个例子说明了如**何用MOV 指令从内存中读值到寄存器(第2行),如何从寄存器写到内存(第3行)。**

关于这段汇编代码有两点值得注意。首先,我们看到C语言中**所谓的“指针”其实就 是地址**。**间接引用指针**就是将**该指针放在一个寄存器中,**然后在**内存引用中使用这个寄存 器**。其次,**像x这样的局部变量**通常是**保存在寄存器**中,而不是内存中。**访问寄存器比访 问内存要快得多**。

##### 3.4.3.1 汇编实现强制类型转换

![image-20210416124744054](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416124744054.png)



#### 3.4.4 压入和弹出栈数据

![image-20210416125056168](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416125056168.png)

最后两个数据传送操作可以将数据压人程序栈中,以及从程序栈中弹出数据,如图3-8 所示。正如我们将看到的,栈在处理过程调用中起到至关重要的作用。栈是一种数据结 构,可以添加或者删除值,不过要遵循“后进先出”的原则。通过push操作把数据压人 栈中,通过pop操作删除数据;它具有一个属性:弹出的值永远是最近被压人而且仍然在 栈中的值。栈可以实现为一个数组,总是从数组的一端插人和删除元素。这一端被称为栈 项。在x86-64中,程序栈存放在内存中某个区域。如图3-9所示,栈向下增长,这样一 来,栈顶元素的地址是所有栈中元素地址中最低的。 (根据惯例,我们的栈是倒过来画的, 栈“顶”在图的底部。)栈指针持sp保存着栈顶元素的地址。

pushq指令的功能是把数据压人到栈上,而popq指令是弹出数据。这些指令都只有 一个操作数一压人的数据源和弹出的数据目的。

将一个四字值压人栈中,首先要将栈指针减8,然后将值写到新的栈顶地址。因此, 指令pushq %rbp的行为等价于下面两条指令:

![image-20210416125845715](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416125845715.png)

它们之间的区别是在机器代码中pushq指令编码为**1个字节**,而上面那两条指令一共需要 **8个字节**。

![image-20210416130051744](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416130051744.png)

图3-9中前两栏给出的是,当%rsp为OxlO8,%rax为Ox123时,执行指令 pushq%rax的效果。首先%rsp会减8,得到Oxlo,然后会将Ox123存放到内存地址 Oxlo处。



弹出一个四字的操作包括从栈顶位置读出数据,然后将栈指针加80 因此,指令p〇pq 宅rax等价于下面两条指令:

![image-20210416175121779](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210416175121779.png)

图3-9的第三栏说明的是在执行完pushq后立即执行指令popq frdx的效果。先从内 存中读出值Ox123,再写到寄存器%rdx中,然后,寄存器%rsp的值将增加回到OxlO80 如图中所示,值Ox123仍然会保持在内存位置OxloO中,直到被覆盖(例如被另一条人栈 操作覆盖)。无论如何,%rsp指向的地址总是栈顶。 因为栈和程序代码以及其他形式的程序数据都是放在同一内存中,所以程序可以用标 准的内存寻址方法访问栈内的任意位置。例如,假设栈顶元素是四字,指令movq8(宅 rsp) ,笔rdx会将第二个四字从栈中复制到寄存器笔rdxo



### 3.5 算术和逻辑操作

**整数算术操作。加载有效地址(leaq)指令通常用来执行简单的算术操作。其余的指令 是更加标准的一元或二元操作。我们用>> A和>>.来分别表示算术右移和逻辑右移。 注意,这里的操作顺序与ATT格式的汇编代码中的相反**

![image-20210419124156141](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210419124156141.png)

图3-10列出了x86-64的一些整数和逻辑操.作。大多数操作都分成了指令类,这些指 令类有各种带不同大小操作数的变种(只有Ieaq没有其他大小的变种)。例如,指令类 ADD由四条加法指令组成‥ addb、 addw、 addl和addq,分别是字节加法、字加法、双 字加法和四字加法。事实上,给出的每个指令类都有对这四种不同大小数据的指令。这些操作被分为四组:加载有效地址、一元操作、二元操作和移位.二元操作有两个操作数, 而一元操作有一个操作数。这些操作数的描述方法与3.4节中所讲的一样。

#### 3.5.1加载有效地址 leap

加载有效地址(load effective address)指令Ieaq实际上是movq指令的变形.它的指 令形式是从内存读数据到寄存器,但实际上它根本就没有引用内存。它的第一个操作数看 上去是一个内存引用,但该指令并不是从指定的位置读人数据,而是将有效地址写人到目 的操作数。在图3-10中我们用C语言的地址操作符&s说明.这种计算这条指令可以**为后 面的内存引用产生指针**.另外,它还可以**简洁地描述普通的算术操作**。例如,如果寄存 器%rdx的值为x,那指令Ieaq 7(%rdx,%rdx,4),frax将设置寄存器%rax的值为5工+ 70编译器经常发现Ieaq的一些灵活用法,根本就与有效地址计算无关。目**的操作数必须 是一个寄存器**。

为了说明Ieaq在编译出的代码中的使用,看看下面这个C程序:

```
  1 
  2 long scale(long x, long y, long z)
  3 {
  4     long t = x + 4 * y + 12 * z;
  5     return t;
  6 }

```

```
  2 x in rdi, y in rsi z in rdx
  3 
  4 scale:
  5     leaq    (%rdi,%rsi,4), %rax 
  6     
  7     //x + 4y
  8     
  9     leaq    (%rdx,%rdx,2), %rcx
 10     
 11     z + 2z = 3z
 12     
 13     leaq    0(,%rcx,4), %rdx
 14     
 15     3z * 4 = 12z
 16     
 17     addq    %rdx, %rax
 18     
 19     x + 4y + 12z
 20     ret

```

leaq指令能执行加法和有限形式的乘法,在编译如上简单的算术表达式时,是很有用处的。



#### 3.5.2 一元和二元操作

第二组中的操作是一元操作,只有一个操作数,既是源又是目的。这个操作数可以是 一个寄存器,也可以是一个内存位置。比如说,指令incq(%rsp)会使栈顶的8字节元素 加10 这种语法让人想起C语言中的加1运算符(++)和减1运算符(一一)。

第三组是二元操作,其中,第二个操作数既是源又是目的。这种语法让人想起C语言 中的赋值运算符,例如x一=yo不过,要注意,源操作数是第一个,目的操作数是第二个, 对于不可交换操作来说,这看上去很奇特。例如,指令subq frax,frdx使寄存器frdx的 值减去%rax中的值。 (**将指令解读成“从%rdx中减去?rax**”会有所帮助。)第一个操作数 可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意, **当第二个操作数为内存地址时,处理器必须从内存读出值,执行操作,再把结果写回 内存**。



#### 3.5.3 移位操作

最后一组是移位操作,先给出移位量,然后第二项给出的是要移位的数。可以进行算 术和逻辑右移。移位量可以是一个立即数,或者放在单字节寄存器宅cl中。 (这些指令很 特别,因为只允许以这个特定的寄存器作为操作数。)原则上来说, 1个字节的移位量使得 移位量的编码范围可以达到28-1==2550.x86-64中,移位操作对砂位长的数据值进行操 作,移位量是由宅cl寄存器的低仍位决定的,这里2加…砂。高位会被忽略。**所以,例如当 寄存器%cl的十六进制值为OxFF时,指令salb会移7位, Salw会移15位, Sall会移 31位,而salq会移63位。**