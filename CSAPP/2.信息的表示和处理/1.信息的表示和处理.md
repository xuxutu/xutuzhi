# 1.信息的表示和处理

1. 无符号加法的溢出检测
   $$
   对于0 <= x,y <=Umax中的x，y,s = x + y,则对计算s，当且仅当s<x(s<y)时，发生了溢出。
   $$

   $$
   证明：
   w = 4时，计算9+12.
   1001 + 1100 = 10101 截断后等于0101，相当于减去16（2^w).
   而Umax = 2^w - 1.
   所以截断后的结果必然小于两个操作数
   $$

2. 有符号加法的溢出检测
   $$
   对满足TMin<= x,y <=TMax 的x和y，令s=x+y.当且仅当x>=0,y>=0,但s<0时，计算s发生了正溢出;
   $$

   $$
   当且紧当x<0, y<0,但s>=0时，
   计算s发生了负溢出。
   $$

   | x         | y         | x+y         | x+y(截断后） | 情况 |
   | --------- | --------- | ----------- | ------------ | ---- |
   | -8 [1000] | -5 [1011] | -13 [10011] | 3 [0011]     |      |
   | -8 [1000] | -8 [1000] | -16 [10000] | 0 [0000]     |      |
   | -8 [1000] | 5 [0101]  | -3  [1101]  | -3 [1101]    |      |
   | 2 [0010]  | 5 [0101]  | 7  [0111]   | 7 [0111]     |      |
   | 5 [0101]  | 5 [0101]  | 10 [1010]   | -6 [1010]    |      |
   |           |           |             |              |      |
   |           |           |             |              |      |

     /*Determine whether arguments can be added without overflow */
     int add_ok(int x, int y)
     {
         int sum = x + y;
         int neg_over = x < 0 && y < 0 && sum >= 0;
         int pos_over = x >= 0 && y >= 0 && sum < 0;
   
   ​      return !neg_over && !pos_over;
     }
   
   3.无论是否溢出，（x+y） - y 的都能得到x

   ```
   -8      +  -5      = 3 ;
   1000 + 1011 = 0011 ;
   
   3      -   -5;		
   0011 -  1011 = 0011 + 0101(2^w - 11) = 1000  = -8
   
   推导的过程中发现就溢出的时候发生截断减少了2^w，而逆元的时候又加了2^w
   ```
   
   4.补码的非
   
   ```
   当x = TMin时，TMin的非等于TMin
   如w=4时
   1000 + 1000 = 10000 = 0000 = 0
   ```
   
   

## 整数运算的最后思考

1.  绝大多数机器上乘法指令相当慢需要十个或更多的时钟周期;除法比乘法更慢，需要30个以上的时钟周期
2. 无符号数据类型会产生让资深程序员意想不到的行为
3. 补码表示提供了一种既能表示正数又能表示负数的灵活用法                                                                                                                                                                                                                                                                                                                        

# 2.浮点数

### 	2.4.1 二进制小数

​	  数字1/5可以用十进制小数10.20精确表示，但无法表示为一个二进制小数。我们只能近似的表示它。增加二进制的长度能够增加表示的精度

| 小数值 | 二进制表示 | 十进制表示 |
| ------ | ---------- | :--------- |
| 1/8    | 0.001      | 0.125      |
| 3/4    | 0.11       | 0.75       |
| 25/16  | 1.1001     | 1.5625     |
| 43/16  | 10.1011    | 1.125      |
| 9/8    | 1.001      | 5.875      |
| 47/8   | 101.111    | 5.875      |
| 51/16  | 11.0011    | 3.1875     |

###     2.4.2 IEEE浮点表示

​			
$$
V = (-1)^s * M *2^E
$$
​			    

