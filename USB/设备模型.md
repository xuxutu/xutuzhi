# 设备模型

### 总线、设备、驱动

```
一个驱动可以支持多个设备
一个设备只能绑定一个驱动

```

bus

```
 struct bus_type {
 		struct kset drivers ;/总线拥有哪些设备
 		struct kset devices;/总线拥有哪些驱动
 }
 
 还是先说说总线中的那两条链表是怎么形成的吧。这要求每次出现一个设备就要向总线汇报，或者说注册，每次出现
一个驱动，也要向总线汇报，或者说注册。
1.比如系统初始化的时候，会扫描连接了哪些设备，并为每一个设备建立起一个 struct device 的变量，
2.每一次有一个驱动程序，就要准备一个struct device_driver 结构的变量
3.把这些变量统统加入相应的链表，device 插入devices 链表，driver 插入 drivers 链表。
4.这样通过总线就能找到每一个设备，每一个驱动。

链表里的 device 和 driver 又是如何联系那？

```

```
struct device {
		struct bus_type * bus; /* type of bus device is on */  表示这个设备连到哪个总线上
		struct device_driver *driver;	/* which driver has allocated this device */ 表示这个设备的驱动是什么
}
```

```
struct device_driver {
		struct bus_type *bus; /表示这个驱动属于哪个总线
		struct klist klist_devices;/表示这个驱动都支持哪些设备
}
```

kobject和kset都是linux设备模型中最基本的元素，**把总线、设备和驱动这样的对象连接到设备模型上**

```
总线、设备、驱动是西瓜，kobjcet、
klist 是种瓜的人，没有幕后种瓜人的汗水不会有清爽解渴的西瓜，我们不能光知道西瓜的
的甜，还要知道种瓜人的辛苦。kobject 和 kset 不会在意自己自己的得失，它们存在的意
义在于把总线、设备和驱动这样的对象连接到设备模型上。种瓜的人也不会在意自己的汗水，
在意的只是能不能送出甜蜜的西瓜。
```



 linux 的设备模型是一个 OO 的体系结构，总线、设备和驱动 都是其中鲜活存在的对象，**kobject 是它们的基类，所实现的只是一些公共的接口，**

 **kobject 嵌入到对象结构里来实现。**

 **kset 是同种类型 kobject 对象的集合，也可以说是对象的容器。**

 **内核使用 kobject 将各个对象连接起来组成了一个分层的结构体系。**

 **kobject 结构里包含了 parent 成员， 指向了另一个 kobject 结构，也就是这个分层结构的上一层结点。**

 **kset 是通过链表来实 现的，**这样就可以明白，struct bus_type 结构中的成员 drivers 和 devices 表示了一条 总线拥有两条链表，**一条是设备链表**，**一条是驱动   链表。**

那么klist那？其实它就包含了一个链表和一个自旋锁，我们暂且把它看成链表也无妨。



### 设备与驱动的结合

```
先有的是 device，每一个要用的 device 在计算机启动之前就已经插好了，插放在它应该在的位置上，然后计算机启动，然后操作系统开始初始化，总线开始扫描设备
每找到一个设备，就为其申请一个 struct device 结构，并且挂入总线中的devices 链表中来。
然后每一个驱动程序开始初始化，开始注册其 struct device_driver结构，然后它去总线的 devices 链表中去寻找(遍历)，去寻找每一个还没有绑定 driver 的设备，即 struct device 中的 struct device_driver 指针仍为空的设备
然后它会去观察
这种设备的特征，看是否是他所支持的设备，如果是，那么调用一个叫做device_bind_driver 的函数，然后他们就结为了秦晋之好。
 1.struct device中的 struct device_driver driver 指向这个 driver，
 2.struct device_driver driver 把struct device 加入他的那张 struct klist klist_devices 链表中来。
```

### 热插拔。

device 可以在计算机启动以后在插入或者拔出计算机了。因此，很难再说是先 有 device 还是先有 driver 了。



### Linux 设备模型中的总线

落实在 USB 子系统里就是 usb_bus_type，它在 usb_init 函数 的 874 行注册，在 driver.c 文件里定义

```
1523 struct bus_type usb_bus_type = {
1524 .name = "usb", //name自然就是usb总线的绰号了，
1525 .match = usb_device_match,//match这个函数指针就比较有意思了，它充当了一个红娘的角色，在总线的设备和驱动之间牵线搭桥，
1526 .uevent = usb_uevent,
1527 .suspend = usb_suspend,
1528 .resume = usb_resume,
1529 }; 
```



### usb设备驱动

```
210 struct usb_device_driver usb_generic_driver = {
211 .name = "usb",
212 .probe = generic_probe,
213 .disconnect = generic_disconnect,
214 #ifdef CONFIG_PM
215 .suspend = generic_suspend,
216 .resume = generic_resume,
217 #endif
218 .supports_autosuspend = 1,
219 }; 

878 struct usb_device_driver {
879 const char *name;
880
881 int (*probe) (struct usb_device *udev);
882 void (*disconnect) (struct usb_device *udev);
883
884 int (*suspend) (struct usb_device *udev, pm_message_t message);
885 int (*resume) (struct usb_device *udev);
886 struct usbdrv_wrap drvwrap;
887 unsigned int supports_autosuspend:1;
888 }; 
```



### usb接口驱动

每个写usb驱动的人心中都有一个 usb_driver。一般来说，我们平时所谓的编写usb驱动指的也就是写usb接口的驱动，需要 以一个struct usb_driver结构的对象为中心，以设备的接口提供的功能为基础，开展usb 驱动的建设。

```
833 struct usb_driver {
834 const char *name;//驱动程序的名字，对应了在/sys/bus/usb/drivers/下面的子目录名称。
和我们每个人一样，它只是彼此区别的一个代号，不同的是我们可以有很多人叫张三或者李
四，但这里的名字在所有的 usb 驱动中必须是唯一的。
835
836 int (*probe) (struct usb_interface *intf,//用来看看这个 usb 驱动是否愿意接受某个接口的函数。每个驱动自诞生
起，它的另一半就已经确定了，这个函数就是来判断哪个才是她苦苦等待的那个他。当然，
这个他应该是他们，因为一个驱动往往可以支持多个接口。
837 const struct usb_device_id *id);
838
839 void (*disconnect) (struct usb_interface *intf);//当接口失去联系，或使用rmmod卸载驱动将它和接口强行分开时
这个函数就会被调用 
840
841 int (*ioctl) (struct usb_interface *intf, unsigned int code,
842 void *buf);
843
844 int (*suspend) (struct usb_interface *intf, pm_message_t message);
845 int (*resume) (struct usb_interface *intf);
//分别在设备被挂起和唤醒时使用。
846 
 73
847 void (*pre_reset) (struct usb_interface *intf);
848 void (*post_reset) (struct usb_interface *intf);
//分别在设备将要复位（reset）和已经复位后
使用。
849
850 const struct usb_device_id *id_table;//驱动支持的所有设备的花名册，所有的三宫六院要想受到宠幸都要在
这里登记。驱动就靠这张表儿来识别是不是支持哪个设备接口的，如果不属于这张表，那就
躲一边儿去吧。
851
852 struct usb_dynids dynids;//支持动态 id 的。什么是动态 id？本来前面刚说每个驱动诞生时她的另一
半在 id_table 里就已经确定了，可是谁规定了女同胞就一定要从一而终了，那是封建旧思
想要打到的，听听她们内心的呼声“谁说我白，瘦，漂亮~我就跟他做好朋友”，Greg 大侠
显然也听到了，于是在一年多前的一个寒风萧萧的日子里平地一声吼，加入了动态 id 的机
 74
制。即使驱动已经加载了，也可以添加新的 id 给她，只要新 id 代表的设备存在，对她说“你
又白又瘦又漂亮”，她就会和他绑定起来。

怎么添加新的 id？到驱动所在的地方瞅瞅，也就是/sys/bus/usb/drivers 目录下边儿，那
里列出的每个目录就代表了一个 usb 驱动，随便选一个进去，能够看到一个 new_id 文件
吧，使用 echo 将厂商和产品 id 写进去就可以了。看看 Greg 举的一个例子
echo 0557 2008 > /sys/bus/usb/drivers/foo_driver/new_id
就可以将 16 进制值 0557 和 2008 写到 foo_driver 驱动的设备 id 表里取。

主要还是因为本来挺单纯的驱动在usb的世界里不得已分成了设备驱动和接口驱
动两种，为了区分这两种驱动，就中间加了这么一层，添了个for_devices标志来判断是哪
种。
779 struct usbdrv_wrap {
780 struct device_driver driver;
781 int for_devices;
782 }; 

853 struct usbdrv_wrap drvwrap;
854 unsigned int no_dynamic_id:1;//可以用来禁止动态 id 的，设置了之后，驱动就从一而终吧，
别七想八想了
855 unsigned int supports_autosuspend:1;//对 autosuspend 的支持，如果设置为 0 的话，就不
再允许绑定到这个驱动的接口 autosuspend。
856 }; 
```



### usb_device_match

**总线上有新设备或新的驱动 添加时，这个函数总是会被调用，如果指定的驱动能够处理指定的设备，也就是匹配成功， 函数返回 0。**

```
92 static inline int is_usb_device_driver(struct device_driver *drv)
93 {
94 return container_of(drv, struct usbdrv_wrap, driver)->
95 for_devices;
96 } 


195 struct device_type usb_device_type = {
196 .name = "usb_device",
197 .release = usb_release_dev,
198 }; 

85 static inline int is_usb_device(const struct device *dev)
86 {
87 return dev->type == &usb_device_type;
88 } 

85 static inline int is_usb_device(const struct device *dev)
86 {
87 return dev->type == &usb_device_type;
88 } 


540 static int usb_device_match(struct device *dev, struct device_driver *drv) //参数我们都已经很熟悉了，对应的就是总线两条链表里的设备和驱动，
541 {
542 /* devices and interfaces are handled separately */
543 if (is_usb_device(dev)) {
544
545 /* interface drivers never match devices */
546 if (!is_usb_device_driver(drv))
547 return 0;
548
549 /* TODO: Add real matching code */
550 return 1;
551
552 } else {
553 struct usb_interface *intf;
554 struct usb_driver *usb_drv;
555 const struct usb_device_id *id;
556
557 /* device drivers never match interfaces */
558 if (is_usb_device_driver(drv))
559 return 0;
560
561 intf = to_usb_interface(dev);
562 usb_drv = to_usb_driver(drv);
563
564 id = usb_match_id(intf, usb_drv->id_table);
565 if (id)
566 return 1;
567
568 id = usb_match_dynamic_id(intf, usb_drv);
569 if (id) 
 37
570 return 1;
571 }
572
573 return 0;
574 } 
```

### 接口

接口是设备的接口。设备可以有多个接口，每个接口代表一个功能， 每个接口对应着一个驱动。



###  

### USB 子系统里的Linux 设备模型的 device 

**struct usb_device**

```

140 struct usb_interface {
141 /* array of alternate settings for this interface,
142 * stored in no particular order */
143 struct usb_host_interface *altsetting; //可选的设置
144
145 struct usb_host_interface *cur_altsetting; /* the currently//表示当前正在使用的设置
146 * active alternate setting */
147 unsigned num_altsetting; /* number of alternate settings */表示这个接口具有可选设置的数量。
148
149 int minor; /* minor number this interface is //分配给接口的次设备号
150 * bound to */
151 enum usb_interface_condition condition; /* state of binding */表示接口和驱动的
绑定状态
前面说linux设备模型的时候说了，设备和驱动是相生相依的关系，总线上的每个设备和驱
动都在等待着命中的那个她，找到了，执子之手与子偕老，找不到，孤苦伶仃北冰洋。enum
usb_interface_condition形象的描绘了这个过程中接口的个中心情，孤苦、期待、幸福、
分开，人生又何尝不是如此？

152 unsigned is_active:1; /* the interface is not suspended */表示接口是不是处于挂起状态

153 unsigned needs_remote_wakeup:1; /* driver requires remote wakeup */表示是否需要
打开远程唤醒功能
远程唤醒允许挂起的设备给主机发信号，通知主机它将从挂起状态恢复，
注意如果此时主机处于挂起状态，就会唤醒主机，不然主机仍然在睡着，设备自个醒过来干
吗用。协议里并没有要求 USB 设备一定要实现远程唤醒的功能，即使实现了，从主机这边
儿也可以打开或关闭它。1

154
155 struct device dev; /* interface specific device info */
156 struct device *usb_dev; /* pointer to the usb class's device, 当接口使用 USB_MAJOR作为主设备号时，usb_dev才会用到，你找遍
整个内核，也只在usb_register_dev和usb_deregister_dev两个函数里能够看到它
usb_dev指向的就是usb_register_dev函数里创建的usb class device。
if any */

157 int pm_usage_cnt; /* usage counter for autosuspend */电源管理，usage_cnt 就是使
用计数，它会自动进入休眠，这就叫 autosuspend

153-157 协议里规定，所有的 usb 设备都必须支
持挂起状态，就是说为了达到节电的目的，当设备在指定的时间内，3ms 吧，如果没有发
生总线传输，就要进入挂起状态。

158 }; 
```

**struct usb_interface**



### 设备的生命线

首先当然是你将 usb 设备连接在 hub 的某个端口上，hub 检测到有设备连接了进来，它也 知道有朋自远方来不亦乐乎，于是精神头儿就上来了，就觉得有必要为设备做点什么。

1.它会 为设备分配一个 struct usb_device 结构的对象并初始化

2.调用设备模型提供的接口将 设备添加到 usb 总线的设备列表里

3.usb 总线会遍历驱动列表里的每个驱动，调用自 己的 match 函数看它们和你的设备或接口是否匹配。

### usb 设备的构造函数

hub 检测到自己的某个端口有设备连接了进来后，它会调用 core 里的 usb_alloc_dev 函 数为 struct usb_device 结构的对象申请内存，这个函数在 usb.c 文件里定义

```
226 /**
227 * usb_alloc_dev - usb device constructor (usbcore-internal)
228 * @parent: hub to which device is connected; null to allocate a root hub
229 * @bus: bus used to access the device
230 * @port1: one-based index of port; ignored for root hubs
231 * Context: !in_interrupt()
232 *
233 * Only hub drivers (including virtual root hub drivers for host
234 * controllers) should ever call this.
235 * 
 78
236 * This call may not be used in a non-sleeping context.
237 */
238 struct usb_device *
239 usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
240 {
241 struct usb_device *dev;
242
243 dev = kzalloc(sizeof(*dev), GFP_KERNEL);//为一个 struct usb_device 结构的对象申请内存并初始化为 0。直到在看到这一
行的前一天，我还仍在使用 kmalloc 加 memset 这对儿最佳拍档来申请内存和初始化，但
是在看到 kzalloc 之后，我知道了江山代代有人出，眉先生，须后生，先生不及后生长的道
理，没看那些 90 后的都在嘲笑咱们 80 后的不知道 kzalloc 了么。kzalloc 直接取代了
kmalloc/memset，一个函数起到了两个函数的作用。这种角色当然是最讨人喜欢的了，
所以说现在那些简历上搞什么艺术照片儿性感写真什么的完全毫无必要，只要写上个能够做
牛做马，白天做牛晚上做马，那些老板就乐翻天了，哪还用玩儿那些虚头

凡是你想用 kmalloc/memset 组合申请内存的时候，就使用 kzalloc 代替吧，
凡是申请内存的，不要忘了判断是不是申请成功了。我们的心里应该把这两个凡是提高到和
四项基本原则一样的地位。

244 if (!dev)
245 return NULL;
246
247 if (!usb_get_hcd(bus_to_hcd(bus))) {
248 kfree(dev);
249 return NULL;
250 }
//这里的两个函数是hcd，主机控制器驱动里的，
//usb的世界里一个主机控制器对应着一条usb总线，
//主机控制器驱动用struct usb_hcd结构表示
//一条总线用struct usb_bus结构表示
//函数bus_to_hcd是为了获得总线对应的主机控制器
驱动，也就是struct usb_hcd结构对象
//函数usb_get_hcd只是将得到的这个usb_hcd
结构对象的引用计数加 1，为什么？因为总线上多了一个设备，设备在主机控制器的数据结
构就得在，当然得为它增加引用计数。

251
252 device_initialize(&dev->dev);//device_initialize 是设备模型里的函数，这里就是将 struct usb_device 结构里
嵌入的那个 struct device 结构体初始化掉，以后好方便用，初始化些什么？
253 dev->dev.bus = &usb_bus_type;
254 dev->dev.type = &usb_device_type;//将设备的设备类型初始化为usb_device_type，这是咱们上节第二次遇到
usb_device_match函数，走设备那条路，使用 is_usb_device判断是不是usb设备时留
下的疑问，就是在这儿把设备的类型给初始化成usb_device_type了。
255 dev->dev.dma_mask = bus->controller->dma_mask;//这个就是与 DMA 传输相关的了，设备能不能进行 dma 传输，得看主机控制器的
脸色，主机控制器不支持的话设备自作多情那也没有用。所以这里 dma_mask 被设置为
host controller 的 dma_mask。
256 dev->state = USB_STATE_ATTACHED;//将 usb 设备的状态设置为 Attached，表示设备已经连接到 usb 接口上了，是 hub
检测到设备时的初始状态。咱们前面说了，USB 设备从生到死都要按照那么几个状态，这
里随着设备生命线的逐渐深入，咱们会看到设备的状态也在逐渐的变化。
257
258 INIT_LIST_HEAD(&dev->ep0.urb_list);
259 dev->ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
260 dev->ep0.desc.bDescriptorType = USB_DT_ENDPOINT;//分别初始化了端点 0 的描述符长度和描述符类型。
261 /* ep0 maxpacket comes later, from device descriptor */
262 dev->ep_in[0] = dev->ep_out[0] = &dev->ep0;
//端点 0 实在是太太太特殊了，这个咱们是一而再再而三的感叹，struct usb_device
里直接就有这么一个成员 ep0，这行就将 ep0 的 urb_list 给初始化掉。因为接下来遇到的
那些主要角色的成员前面集中都说过了，咱们就不再说它们是嘛意思了，忘了的话可以到前
面看看。

263
264 /* Save readable and stable topology id, distinguishing devices
265 * by location for diagnostics, tools, driver model, etc. The
266 * string is a path along hub ports, from the root. Each device's
267 * dev->devpath will be stable until USB is re-cabled, and hubs
268 * are often labeled with these port numbers. The bus_id isn't
269 * as stable: bus->busnum changes easily from modprobe order,
270 * cardbus or pci hotplugging, and so on.
271 */
272 if (unlikely(!parent)) {
273 dev->devpath[0] = '';
//unlikely(x)就是告诉编译器条件 x 发生的
可能性不大，那么这个条件块儿里语句的目标码可能就会被放在一个比较远的为止，以保证
经常执行的目标码更紧凑。likely 则相反。在一个月高风黑的夜晚，你向你从穿开裆裤就开
始暗恋的 mm 表白，她回复你
 if(unlikely(你以后会有房子，不是按揭的，会有车子，不是奥拓))
 咱们明天可以去领证儿
你觉得你是应该高兴还是不应该高兴？她这明摆着就是告你别做梦了，你有房子车子的可能
性太小了，往远处排吧，她要先照顾有房有车的。如果没看过内核，你说不定还兴高采烈觉
得成了那，你会觉得以后房子车子还不是小 case。所以，这里要感叹一下，读内核是多么
重要啊。

274
275 dev->dev.parent = bus->controller;
276 sprintf(&dev->dev.bus_id[0], "usb%d", bus->busnum);
277 } else {
278 /* match any labeling on the hubs; it's one-based */
279 if (parent->devpath[0] == '') 
 79
280 snprintf(dev->devpath, sizeof dev->devpath,
281 "%d", port1);
282 else
283 snprintf(dev->devpath, sizeof dev->devpath,
284 "%s.%d", parent->devpath, port1);
285
286 dev->dev.parent = &parent->dev;
287 sprintf(&dev->dev.bus_id[0], "%d-%s",
288 bus->busnum, dev->devpath);
289
290 /* hub driver sets up TT records */
291 }
行整个的代码就是首先判断你的设备是不是直接连到 root hub 上的，如果是，
将 dev->devpath[0]赋值为‘0’，以示特殊，然后父设备设为 controller，同时把
dev->bus_id[]设置为像 usb1/usb2/usb3/usb4 这样的字符串。如果你的设备不是直接
连到 root hub 上的，有两种情况，如果你的设备连接的那个 hub 是直接连到 root hub 上
的，则 dev->devpath 就等于端口号，否则 dev->devpath 就等于在父 hub 的 devpath
基础上加一个‘.’再加一个端口号，最后把 bus_id[]设置成 1-/2-/3-/4-这样的字符串后
面连接上 devpath。

292
293 dev->portnum = port1;
294 dev->bus = bus;
295 dev->parent = parent;
296 INIT_LIST_HEAD(&dev->filelist);//初始化一个队列，usbfs 用的。
297
298 #ifdef CONFIG_PM
299 mutex_init(&dev->pm_mutex);
300 INIT_DELAYED_WORK(&dev->autosuspend, usb_autosuspend_work);
301 dev->autosuspend_delay = usb_autosuspend_delay * HZ;
302 #endif
303 return dev;
//298~302 行，电源管理的，仍然飘过。
304 }
usb_alloc_dev 函数就相当于 usb 设备的构造函数，参数里边儿，parent 是设备连接的
那个 hub，	bus 是设备连接的那条总线，port1 就是设备连接在 hub 上的那个端口。

```



### 设备的生命线（二）

现在设备的 struct usb_device 结构体已经准备好了，只是还不怎么饱满，hub 接下来就 会给它做做整容手术，往里边儿塞点什么，充实一些内容。比如：

1.将设备的状态设置为 Powered

2.因为此时还不知道设备支持的速度，于是将设备的 speed 成 员暂时先设置为 USB_SPEED_UNKNOWN；

3.设备的级别 level 当然会被设置为 hub 的 level 加上 1 了；

4.还有为设备能够从 hub 那里获得的电流赋值；

5.为了保证通信畅通，hub 还会为设备在总上选择一个独一无二的地址。

**集中列了下到目前为止，设备结构体里成员的状况*

![image-20210402192629788](/home/zhaoyong/.config/Typora/typora-user-images/image-20210402192629788.png)	

现在就算设备成功复位了

1.大步迈进了 **Default** 状态

2.hub 也会获得设备真正的速 度，低速、全速也好，高速也罢，总算是浮出水面了

3.speed 也终于知道了自己的真正身 份，不用再是 UNKNOWN 了。那根据这个速度，咱们能知道些什么？起码能够知道端点 0 一次能够处理的最大数据长度啊，协议里说，对于高速设备，这个值为为 64 字节，对于低 速设备为 8 字节，而对于全速设备可能为 8，16，32，64 其中的一个。

**hub 也辛苦的蛮久了，设备也该进入 Address 状态了**

咱们的设备要想进入 Address 状态没那么费劲儿，只要 hub 使用 core 里定义的一个函数 usb_control_msg，发送 SET_ADDRESS 请求给设备，设备就兴高采烈的迈进 Address 了。

那么设备的这个 address 是什么，就是上面的 devnum 啊，

### 进入 Address 状态

这个函数主要目的是创建一个控制 urb，并把它发送给 usb 设备，然后等待它完成。urb 是什么？忘了么，前面提到过的，你要想和你的 usb 通信，就得创建一个 urb，并且为它 赋好值，交给 usb core，它会找到合适的 host controller，从而进行具体的数据传输。

```
//描述了主机通过控制传输发送给设备的请求
（Device Requests）
140 struct usb_ctrlrequest {
141 __u8 bRequestType;//bRequestType，这个字段别看就一个字节，内容很丰富的，大道理往往都包含
 88
这种在小地方。它的 bit7 就表示了控制传输中 DATA transaction 阶段的方向，当然，如
果有 DATA 阶段的话。bit5~6 表示 request 的类型，是标准的，class-specific 的还是
vendor-specific 的。bit0~4 表示了这个请求针对的是设备，接口，还是端点。内核为它
们专门量身定做了一批掩码，也在 ch9.h 文件里，
142 __u8 bRequest;//表示具体是哪个 request。
143 __le16 wValue;//这个字段是 request 的参数，request 不同，wValue 就不同。
144 __le16 wIndex;//也是 request 的参数，bRequestType 指明 request 针对的是设备上
的某个接口或端点的时候，wIndex 就用来指明是哪个接口或端点。
145 __le16 wLength;//控制传输中 DATA transaction 阶段的长度，方向已经在
bRequestType 那儿指明了。如果这个值为 0，就表示没有 DATA transaction 阶段，
 89
bRequestType 的方向位也就无效了。
146 } __attribute__ ((packed)); 

120 int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,
__u8 requesttype,
121 __u16 value, __u16 index, void *data, __u16 size, int
timeout)
122 {
123 struct usb_ctrlrequest *dr = kmalloc(sizeof(struct usb_ctrlrequest),
GFP_NOIO);//为一个 struct usb_ctrlrequest 结构体申请了内存
124 int ret;
125
126 if (!dr)
127 return -ENOMEM;
128
129 dr->bRequestType= requesttype;
130 dr->bRequest = request;
131 dr->wValue = cpu_to_le16p(&value);
132 dr->wIndex = cpu_to_le16p(&index);
133 dr->wLength = cpu_to_le16p(&size);
129 到 133 行就是来使用传递过来的参数初始化这个结构体的。
134
135 //dbg("usb_control_msg");
136
137 ret = usb_internal_control_msg(dev, pipe, dr, data, size, timeout);
138
139 kfree(dr);
140
141 return ret;
142 } 
```



### 设备的生命线（三）

这个函数粗看过去，可以概括为一个中心，三个基本点，以一个struct urb结构体为中心， 以 usb_alloc_urb、usb_fill_control_urb、usb_start_wait_urb三个函数为基本点。 

一个中心：struct urb结构体，就是咱们前面多次提到又多次飘过，只闻其名不见其形的传 说中的urb，全称usb request block，站在咱们的角度看，usb通信靠的就是它这张脸。 

第一个基本点：usb_alloc_urb函数，创建一个urb，struct urb结构体只能使用它来创建， 它是urb在usb世界里的独家代理，和天盛一样的角色。 

第二个基本点：usb_fill_control_urb函数，初始化一个控制urb，urb被创建之后，使用 之前必须要正确的初始化。 

第三个基本点：usb_start_wait_urb函数，将urb提交给咱们的usb core，以便分配给特 定的主机控制器驱动进行处理，然后默默的等待处理结果，或者超时。

```
70 // returns status (negative) or length (positive)
71 static int usb_internal_control_msg(struct usb_device *usb_dev,
72 unsigned int pipe,
73 struct usb_ctrlrequest *cmd,
74 void *data, int len, int timeout)
75 {
76 struct urb *urb;
77 int retv;
78 int length;
79
80 urb = usb_alloc_urb(0, GFP_NOIO);
81 if (!urb)
82 return -ENOMEM;
83 
 90
84 usb_fill_control_urb(urb, usb_dev, pipe, (unsigned char *)cmd, data,
85 len, usb_api_blocking_completion, NULL);
86
87 retv = usb_start_wait_urb(urb, timeout, &length);
88 if (retv < 0)
89 return retv;
90 else
91 return length;
92 }

```



### 使用 urb 来完成一次完整的 usb 通信

1.驱动程序发现自 己有与 usb 设备通信的需要，于是创建一个 urb，并指定它的目的地是设备上的哪个端点

2.然后提交给 usb core，usb core 将它修修补补的做些美化之后再移交给主机控制器的驱 动程序 HCD，

3.HCD 会去解析这个 urb，了解它的目的是什么，并与 usb 设备进行相应的 交流，在

4.交流结束，urb 的目的达到之后，HCD 再把这个 urb 的所有权移交回驱动程序。

### 管道

先看看管道，也就是这个整型值的构成，bit7 用来表示方向，bit8~14 表示设备地址， bit15~18 表示端点号，早先说过，设备地址用 7 位来表示，端点号用 4 位来表示，剩下 来的 bit30~31 表示管道类型。再看看围绕管道的一些宏，在 include/linux/usb.h 里定 义

```
1407 #define PIPE_ISOCHRONOUS 0
1408 #define PIPE_INTERRUPT 1
1409 #define PIPE_CONTROL 2
1410 #define PIPE_BULK 3
1411
1412 #define usb_pipein(pipe) ((pipe) & USB_DIR_IN)
1413 #define usb_pipeout(pipe) (!usb_pipein(pipe))
1414
1415 #define usb_pipedevice(pipe) (((pipe) >> 8) & 0x7f)
1416 #define usb_pipeendpoint(pipe) (((pipe) >> 15) & 0xf)
1417
1418 #define usb_pipetype(pipe) (((pipe) >> 30) & 3) 
 104
1419 #define usb_pipeisoc(pipe) (usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)
1420 #define usb_pipeint(pipe) (usb_pipetype((pipe)) == PIPE_INTERRUPT)
1421 #define usb_pipecontrol(pipe) (usb_pipetype((pipe)) == PIPE_CONTROL)
1422 #define usb_pipebulk(pipe) (usb_pipetype((pipe)) == PIPE_BULK)
```

**内核的 include/linux/usb.h 文件里多了很多专门用来创建不同管道的宏。**

```
__create_pipe宏只是一个幕后的角色，用来将设备地址和端点号放在管道正确的位置上。
1432 static inline unsigned int __create_pipe(struct usb_device *dev,
1433 unsigned int endpoint)
1434 {
1435 return (dev->devnum << 8) | (endpoint << 15);
1436 }
1437
1438 /* Create various pipes... */
1439 #define usb_sndctrlpipe(dev,endpoint) \
1440 ((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint))
1441 #define usb_rcvctrlpipe(dev,endpoint) \
1442 ((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
1443 #define usb_sndisocpipe(dev,endpoint) \ 
 105
1444 ((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint))
1445 #define usb_rcvisocpipe(dev,endpoint) \
1446 ((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
1447 #define usb_sndbulkpipe(dev,endpoint) \
1448 ((PIPE_BULK << 30) | __create_pipe(dev,endpoint))
1449 #define usb_rcvbulkpipe(dev,endpoint) \
1450 ((PIPE_BULK << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
1451 #define usb_sndintpipe(dev,endpoint) \
1452 ((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint))
1453 #define usb_rcvintpipe(dev,endpoint) \
1454 ((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN) 
```

### 什么是 DMA？

就是外设，比如咱们的 **usb 摄像头，和内存之间直接进 行数据交换，把 CPU 给撇一边儿了**，本来，在咱们的电脑里，CPU 自认为是老大，什么事 都要去插一脚，都要经过它去协调处理，和地球对面的那个美利坚合众国差不多。可是这样 的话就影响了数据传输的速度，就像革命青年上山下乡那会儿，谁对哪个 mm 有意思了， 要先向自己的老爸老妈汇报思想动态，说想和哪家姑娘处对象，等着老爸老妈经过高层协商 说可以交往了，然后才能和人家姑娘见面，这多慢啊，哪像现在，老爸老妈都不知道那，下 一代可能都已经培育出来了，有 DMA 和没有 DMA 区别就是这么大。

usb 的世界里也是要与时俱进，要创建和谐社会的，所以 dma 也是少不了的。一般来说， 都是驱动里提供了 kmalloc 等分配的缓冲区，HCD 做一定的 DMA 映射处理，DMA 映射 是干吗的？外设和内存之间进行数据交换，总要互相认识吧，难不成是在衡山路的酒吧啊， 会有不认识的 mm 过来和你答腔，外设是通过各种总线连到主机里边儿的，使用的是总线 地址，而内存使用的是虚拟地址，它们之间本来就是两条互不相交的平行线，要让它们中间 产生连接点，必须得将一个地址转化为另一个地址，这样才能找得到对方，才能互通有无， 而 DMA 映射就是干这个的。这只是轻描淡写三言两语的粗略说法，实际上即使千言万语也 道不完的。它可是高技术含量的活儿，不是看看报纸喝喝茶，开开会泡泡 mm 就能搞定的， 所以在某些平台上非常的费时费力，为了分担点 HCD 的压力，于是就有了这里的两个标志， 告诉 HCD 不要再自己做 DMA 映射了，驱动提供的 urb 里已经提供有 DMA 缓冲区地址， 为领导分忧解难是咱们这些小百姓应该做的事情。



### DMA 缓冲区

```
transfer_buffer
transfer_dma
setup_packet
setup_dma
```



### struct urb 

很早很早很早很早以前就说过，主机与设备之间通过管道来传输数据，管道的一端是主机上 的一个缓冲区，另一端是设备上的端点。管道之中流动的数据，在主机控制器和设备看来是 一个个 packets，在咱们看来就是 **urb**。因而，端点之中就有那么一个队列，叫 **urb 队列**。不过，这并不代表一个 urb 只能发配给一个端点，它可能通过不同的管道发配给不同的端 点，那么这样一来，我们如何知道这个 urb 正在被多少个端点使用，如何判断这个 urb 的 生命已经 over？如果没有任何一个端点在使用它，而我们又无法判断这种情况，它就会永 远的飘荡在 usb 的世界里，犹如飘荡在人冥两届的冤魂。我们需要寻求某种办法在这种情 况下给它们一个好的归宿，这就是引用计数。每多一个使用者，它的这个引用计数就加 1， 每减少一个使用者，引用计数就减一，如果连最后一个使用者都释放了这个 urb，宣称不再 使用它了，那它的生命周期就走到了尽头，会自动的销毁。



```
23 struct kref {
24 atomic_t refcount;
25 }; 
这个结构与 struct urb 相比简约到极致了，简直就是迎着咱们的口味来的。不过别看它简
单，内核里就是使用它来判断一个对象还有没有用的。它里边儿只包括了一个原子变量，为
什么是原子变量？既然都使用引用计数了，那就说明可能同时有多个地方在使用这个对象，
总要考虑一下它们同时修改这个计数的可能性吧，也就是俗称的并发访问，那怎么办？加个
锁？就这么一个整数值专门加个锁未免也忒大材小用了些，所以就使用了原子变量。围绕这
个结构，内核里还定义了几个专门操作引用计数的函数，它们在 lib/kref.c 里定义

kref_init初始化
21 void kref_init(struct kref *kref)
22 { 
 96
23 atomic_set(&kref->refcount,1);
24 smp_mb();
25 } 

kref_get将引用计数加 1
31 void kref_get(struct kref *kref)
32 {
33 WARN_ON(!atomic_read(&kref->refcount));
34 atomic_inc(&kref->refcount);
35 smp_mb__after_atomic_inc();
36 }

kref_put将引用计数减一并判断是不是为 0，为 0 的话就调用参数里release函数指针指向
的函数把对象销毁掉。
52 int kref_put(struct kref *kref, void (*release)(struct kref *kref))
53 {
54 WARN_ON(release == NULL);
55 WARN_ON(release == (void (*)(struct kref *))kfree);
56
57 if (atomic_dec_and_test(&kref->refcount)) {
58 release(kref);
59 return 1;
60 }
61 return 0;
62 } 

它们对独苗儿refcount的操作都是通过原子变量特有的操作函数
其实这句话可以当选当日最大废话，原子变量当然要使用专门的操作函数了，编译器还能做
些优化，否则直接使用一般的变量就可以了干吗还要使用原子变量，不是没事找事儿么，再
说如果你直接像对待一般整型值一样对待它，编译器也会看不过去你的行为，直接给你个
error的。
友情提醒一下，kref_init初始化时，是把refcount的值初始化为 1 了的，不是 0。
还有一点要说的是 kref_put参数里的那个函数指针，你不能传递一个NULL过去，否则这
个引用计数就只是计数，而背离了最初的目的，要记住我们需要在这个计数减为 0 的时候
将嵌入这个引用计数struct kref结构体的对象给销毁掉，所以这个函数指针也不能为
kfree，因为这样的话就只是把这个struct kref结构体给销毁了，而不是整个对象。

464 void usb_kill_urb(struct urb *urb)
465 {
466 might_sleep();//466 行，因为 usb_kill_urb函数要一直等候着HCD将urb终止掉，它必须是可以休眠的，
467 if (!(urb && urb->dev && urb->dev->bus))//这里就是判断一下 urb，urb 要去的那个设备，还有那个设备在的总线有没有，如
果哪个不存在，就还是返回吧
468 return;
469 spin_lock_irq(&urb->lock);//去获得每个urb都有的那把锁，然后将 reject加 1。加 1 有什么用？其实目前版本
的内核里只有两个地方用到了这个值进行判断。第一个地方是在usb core将urb提交给
HCD，正在办移交手续的时候，如果reject大于 0，就不再接着移交了，也就是说这个urb
被HCD给拒绝了。这是为了防止这边儿正在终止这个urb，那边儿某个地方却又妄想将这个
urb重新提交给HCD。
470 ++urb->reject;
471 spin_unlock_irq(&urb->lock);
472
473 usb_hcd_unlink_urb(urb, -ENOENT);//这里告诉HCD驱动要终止这个urb了，usb_hcd_unlink_urb函数也只是告诉HCD
一声，然后不管HCD怎么处理就返回了。
474 wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);//上面的 usb_hcd_unlink_urb是返回了，但并不代表HCD已经将urb给终止了，
HCD可能没那么快，所以这里 usb_kill_urb要休息休息，等人通知它。这里使用了
wait_event宏来实现休眠，usb_kill_urb_queue是在hcd.h里定义的一个等待队列，专
门给 usb_kill_urb休息用的。需要注意的是这里的唤醒条件，use_count必须等于 0，终
于看到 use_count实战的地方了。
475
476 spin_lock_irq(&urb->lock);//再次获得 urb 的那把锁，将 reject 刚才增加的那个 1 给减掉。urb 都已经终止了，
也没人再会去拒绝它了，reject 还是开始什么样儿结束的时候就什么样吧。
477 --urb->reject;
478 spin_unlock_irq(&urb->lock);
479 }

1126 struct urb
1127 {
1128 
1129 struct kref kref; /* reference count of the URB */urb 的引用计数。甭看它是隐藏在 urb 内部的一个不起眼的小角色，但小
角色做大事情，它决定了一个 urb 的生死存亡。一个 urb 有用没用，是继续委以重任还是
无情销毁都要看它的脸色。那第一个问题就来了，为什么 urb 的生死要掌握在这个小小的
引用计数手里边儿？

1130 spinlock_t lock; /* lock for the URB */一把自旋锁。
1131 void *hcpriv; /* private data for host controller//走到今天，你应该明白这个 urb 最终还是要提交给主机控制器驱动的，
这个字段就是 urb 里主机控制器驱动的自留地，咱们就不插手了。
*/
1132 atomic_t use_count; /* concurrent submissions counter */
1133 u8 reject; /* submissions will fail */
1134
1135 /* public: documented fields in the urb that can be used by drivers */
1136 struct list_head urb_list; /* list head for use by the urb's //urb_list，还记得每个端点都会有的那个 urb 队列么？那个队列就是由这里的
urb_list 一个一个的链接起来的。HCD 每收到一个 urb，就会将它添加到这个 urb 指定的
那个端点的 urb 队列里去。这个链表的头儿在哪儿？当然是在端点里，就是端点里的那个
struct list_head 结构体成员。
1137 * current owner */
1138 struct usb_device *dev; /* (in) pointer to associated device */它表示的是 urb 要去的那个 usb 设备。
1139 unsigned int pipe; /* (in) pipe information */pipe，urb 到达端点之前，需要经过一个通往端点的管道，就是这个 pipe。那
第一个问题，怎么表示一个 pipe？人生有两极，管道有两端，一端是主机上的缓冲区，一
 103
端是设备上的端点，
1140 int status; /* (return) non-ISO status */urb 的当前状态
1141 unsigned int transfer_flags; /* (in) URB_SHORT_NOT_OK | ...*/
1142 void *transfer_buffer; /* (in) associated data buffer */
1143 dma_addr_t transfer_dma; /* (in) dma addr for transfer_buffer */
1144 int transfer_buffer_length; /* (in) data buffer length */
前面说
过管道的一端是主机上的缓冲区，一端是设备上的端点，这三个家伙就是描述主机上的那个
缓冲区的。transfer_buffer 是使用 kmalloc 分配的缓冲区，transfer_dma 是使用
usb_buffer_alloc 分配的 dma 缓冲区，HCD 不会同时使用它们两个，如果你的 urb 自带
了 transfer_dma，就要同时设置 URB_NO_TRANSFER_DMA_MAP 来告诉 HCD 一声，
不用它再费心做 DMA 映射了。transfer_buffer 是必须要设置的，因为不是所有的主机控
制器都能够使用 DMA 的，万一遇到这样的情况，也好有个备用。transfer_buffer_length
指的就是 transfer_buffer 或 transfer_dma 的长度。

1145 int actual_length; /* (return) actual transfer length */urb 结束之后，会用这个字段告诉你实际上传输了多少数据。
1146 unsigned char *setup_packet; /* (in) setup packet (control only) */
1147 dma_addr_t setup_dma; /* (in) dma addr for setup_packet */
setup_packet，setup_dma，同样是两个缓冲区，一个是kmalloc分
配的，一个是用usb_buffer_alloc分配的，不过，这两个缓冲区是控制传输专用的，记得
struct usb_ctrlrequest不？它们保存的就是一个struct usb_ctrlrequest结构体，如果
你的urb设置了setup_dma，同样要设置URB_NO_SETUP_DMA_MAP标志来告诉HCD。
如果进行的是控制传输，setup_packet是必须要设置的，也是为了防止出现主机控制器不
能使用DMA的情况。

1148 int start_frame; /* (modify) start frame (ISO) */如果你没有指定 URB_ISO_ASAP 标志，就必须自己设置
start_frame，指定等时传输在哪帧或微帧开始。如果指定了 URB_ISO_ASAP，urb 结束
时会使用这个值返回实际的开始帧号。
1149 int number_of_packets; /* (in) number of ISO packets */
1150 int interval; /* (modify) transfer interval
1151 * (INT/ISO) */
1152 int error_count; /* (return) number of ISO errors */
1153 void *context; /* (in) context for completion */驱动设置了给下面的结束处理函数用的。比如可以将自己驱动里描述
自己设备的结构体放在里边儿，在结束处理函数里就可以取出来。
1154 usb_complete_t complete; /* (in) completion routine */
1155 struct usb_iso_packet_descriptor iso_frame_desc[0];
1156 /* (in) ISO ONLY */ 
 95
1157 };
“年度最大赃物”——俄罗斯一神秘男子偷走跨度达 5 米的整座钢
```

### **设备的生命线（五）**

#### usb_alloc_urb函数

创建urb的专用函数，为一个urb申请内存并做初始 化，在urb.c里定义。

```
56 struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)
57 {
58 struct urb *urb;
59
60 urb = kmalloc(sizeof(struct urb) +
61 iso_packets * sizeof(struct usb_iso_packet_descriptor),
62 mem_flags);
63 if (!urb) {
64 err("alloc_urb: kmalloc failed");
65 return NULL;
66 }
67 usb_init_urb(urb);
68 return urb;
69 } 
usb_alloc_urb说：别看我简单，我也是很有内涵的。先看第一个问题，
它的第一个参数 iso_packets ，表示的是 struct urb 结构最后那个变长数组
iso_frame_desc的元素数目，也就是应该与number_of_packets的值相同，所以对于控
制/中断/批量传输，这个参数都应该为 0。这也算是给咱们示范了下变长数组咋个用法，内
核里到处都是C的示范工程。

81 void usb_free_urb(struct urb *urb)
82 {
83 if (urb)
84 kref_put(&urb->kref, urb_destroy);
85 }
usb_free_urb更潇洒，只调用 kref_put将urb的引用计数减一，减了之后如果变为 0，也
就是没人再用它了，就调用 urb_destroy将它销毁掉。
```

#### usb_fill_control_urb函数

```
1175 static inline void usb_fill_control_urb (struct urb *urb,
1176 struct usb_device *dev,
1177 unsigned int pipe,
1178 unsigned char *setup_packet,
1179 void *transfer_buffer,
1180 int buffer_length,
1181 usb_complete_t complete_fn,
1182 void *context)
1183 {
1184 spin_lock_init(&urb->lock);
1185 urb->dev = dev;
1186 urb->pipe = pipe;
1187 urb->setup_packet = setup_packet;
1188 urb->transfer_buffer = transfer_buffer;
1189 urb->transfer_buffer_length = buffer_length;
1190 urb->complete = complete_fn;
1191 urb->context = context;
1192 } 
```

#### usb_fill_bulk_urb

```
1207 static inline void usb_fill_bulk_urb (struct urb *urb,
1208 struct usb_device *dev,
1209 unsigned int pipe,
1210 void *transfer_buffer,
1211 int buffer_length,
1212 usb_complete_t complete_fn,
1213 void *context)
1214 {
1215 spin_lock_init(&urb->lock);
1216 urb->dev = dev;
1217 urb->pipe = pipe;
1218 urb->transfer_buffer = transfer_buffer;
1219 urb->transfer_buffer_length = buffer_length;
1220 urb->complete = complete_fn;
1221 urb->context = context;
1222 } 
```

####  usb_fill_int_urb

```
static inline void usb_fill_int_urb (struct urb *urb,
1243 struct usb_device *dev,
1244 unsigned int pipe,
1245 void *transfer_buffer,
1246 int buffer_length,
1247 usb_complete_t complete_fn,
1248 void *context,
1249 int interval)
1250 {
1251 spin_lock_init(&urb->lock);
1252 urb->dev = dev;
1253 urb->pipe = pipe;
1254 urb->transfer_buffer = transfer_buffer;
1255 urb->transfer_buffer_length = buffer_length;
1256 urb->complete = complete_fn;
1257 urb->context = context;
1258 if (dev->speed == USB_SPEED_HIGH)
1259 urb->interval = 1 << (interval - 1);
1260 else
1261 urb->interval = interval;
1262 urb->start_frame = -1;
1263 } 
```

#### 等时传输对应的那个初始化函数

作为一个共产主义接班人，我们很快就能发现 usb_fill_control_urb的孪生兄弟里，少了 等时传输对应的那个初始化函数，三缺一啊，在哪里都会是个遗憾。不是不想有，而是没办 法，对于等时传输，urb里是可以指定进行多次传输的，你必须一个一个的对那个变长数组 iso_frame_desc里的内容进行初始化，没人帮得了你。难道你能想出一个办法搞出一个适 用于各种情况等时传输的初始化函数？我是不能。如果想不出来，使用urb进行等时传输的 时候，还是老老实实的对里面相关的字段一个一个的填内容吧。如果想找个例子旁观一下别 人是咋初始化的，可以去找个摄像头驱动，或者其它usb音视频设备的驱动看看，内核里也 有一些的。

### usb_start_wait_urb函数

将前面历经千辛万苦创建和初始化的 urb提交给咱们的usb core，让它移交给特定的主机控制器驱动进行处理，然后望眼欲穿的 等待HCD回馈的结果，如果等待的时间超过了预期的限度，它不会再等，不会去变成望夫 石。

```
33 static int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length) 
 117
34 {
35 struct completion done;
36 unsigned long expire;
37 int status;
38
39 init_completion(&done);
40 urb->context = &done;
41 urb->actual_length = 0;
42 status = usb_submit_urb(urb, GFP_NOIO);
43 if (unlikely(status))
44 goto out;
提交 urb，并返回一个值表示是否提交成功了，显然，成功的
可能性要远远大于失败的可能性，不然就是或者写代码的哥们儿有问题，或者就是我有问题，
所以接下来的判断加上了 unlikely，如果你真的那么衰，遇上了小概率事件，那也就没必
要在 47 行等通知了，直接到后边儿去吧。
45
46 expire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;

等待通知，我们需要知道的是怎么去判断等待的结果，也就是
wait_for_completion_timeout 的返回值代表什么意思？一般来说，一个函数返回了 0
代表了好消息，一切顺利，如果你这么想那可就错了。wait_for_completion_timeout
返回 0 恰恰表示的是坏消息，表示直到超过了自己的忍耐的极限仍没有接到任何的回馈，
而返回了一个大于 0 的值则表示接到通知了，那边儿不管是完成了还是出错了总归是告诉
这边儿不用再等了，这个值具体的含义就是距你设定的时限提前了多少时间。为什么会这
样？你去看看 wait_for_completion_timeout 的定义就知道了，我就不贴了，它是通过
schedule_timeout 来实现超时的，schedule_timeout 的返回值就是这么个意思。
47 if (!wait_for_completion_timeout(&done, expire)) {
48
49 dev_dbg(&urb->dev->dev,
50 "%s timed out on ep%d%s len=%d/%d\n",
51 current->comm,
52 usb_pipeendpoint(urb->pipe),
53 usb_pipein(urb->pipe) ? "in" : "out",
54 urb->actual_length,
55 urb->transfer_buffer_length);
56
57 usb_kill_urb(urb);
58 status = urb->status == -ENOENT ? -ETIMEDOUT : urb->status;
59 } else
60 status = urb->status;
61 out:
62 if (actual_length)
63 *actual_length = urb->actual_length;
64
65 usb_free_urb(urb);
66 return status;
67 } 
```



### 设备的生命线（六）

#### **usb_submit_urb 函数**

```
220 int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
221 {
222 int pipe, temp, max;
223 struct usb_device *dev;
224 int is_out;
225
226 if (!urb || urb->hcpriv || !urb->complete)226 行，一些有关存在性的判断，某主义的哲学告诉我们：存在是检验真理的唯一标准。
所以这个函数的开头儿就要履行一下常规的检验，urb 为空，都没有初始化是不可以提交给
core 的，core 很生气，后果很严重，hcpriv 本来说好了留给 HCD 用的，你得保证送过去
的时候它还是贞洁的，自己不能偷偷先用了，HCD 很生气，后果也会很严重，complete，
每个 urb 结束了都必须的调用一次 complete 代表的函数，这是真理，你必须得让它存在。
227 return -EINVAL;
228 if (!(dev = urb->dev) || 
 124
229 (dev->state < USB_STATE_DEFAULT) ||
230 (!dev->bus) || (dev->devnum <= 0))
231 return -ENODEV;
上边儿是对 urb 本身的检验，这里是对 urb 的目的地 usb 设备的检验。设备所属
于的那条总线不存在，或者设备本身不存在，你 urb 还嚷嚷着要过去要过去，也太苏维埃
了吧？或者设备甚至还没进入 USB_STATE_DEFAULT 状态，管道的另一端还都是堵着的
怎么过去，早先强调多少回了，要想让设备回应你，它起码得达到 Default 状态。设备编
号 devnum 肯定是不能为负的了，那为 0 为什么也不行那？到现在，地球人都知道了，
Token 包的地址域里有 7 位是表示设备地址的，也就是说总共可以有 128 个地址来分配给
设备，但是其中 0 号地址是被保留作为缺省地址用的，任何一个设备处于 Default 状态还
没有进入 Address 状态的时候都需要通过这个缺省地址来响应主机的请求，所以 0 号地址
不能分配给任何一个设备，hub 为设备选择一个地址的时候，只有选择到一个大于 0 的地
址，设备的生命线才会继续，才会走到这里，因此说这里的 devnum 是不可能也不应该为
0 的，如果为 0 的话，那就是中间哪里谁暗地里动了手脚，就没必要往下走了。

232 if (dev->bus->controller->power.power_state.event != PM_EVENT_ON
233 || dev->state == USB_STATE_SUSPENDED)
234 return -EHOSTUNREACH;
235
236 urb->status = -EINPROGRESS;常规检查都做完了，core 和 HCD 已经认同了这个 urb，就将它的状态设置为
-EINPROGRESS，表示从现在开始 urb 的控制权就在 core 和 HCD 手里边儿了，驱动那
里是看不到这个状态的。
237 urb->actual_length = 0;
238
239 /* Lots of sanity checks, so HCDs can rely on clean data
240 * and don't need to duplicate tests
241 */
242 pipe = urb->pipe;//这几行获得管道的类型还有方向。
243 temp = usb_pipetype(pipe);
244 is_out = usb_pipeout(pipe);
245
246 if (!usb_pipecontrol(pipe) && dev->state < USB_STATE_CONFIGURED)246 行，在设备进入 Configured 状态之前，主机只能使用控制传输，通过缺省管道，也
就是管道 0 来和设备进行交流。
247 return -ENODEV;
248
249 /* FIXME there should be a sharable lock protecting us against
250 * config/altsetting changes and disconnects, kicking in here
251 * (here == before maxpacket, and eventually endpoint type,
252 * checks get made.)
253 */
254
255 max = usb_maxpacket(dev, pipe, is_out);
256 if (max <= 0) {
257 dev_dbg(&dev->dev,
258 "bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",
259 usb_pipeendpoint(pipe), is_out ? "out" : "in",
260 __FUNCTION__, max);
261 return -EMSGSIZE;
262 }
263
264 /* periodic transfers limit size per frame/uframe,
265 * but drivers only control those sizes for ISO.
266 * while we're checking, initialize return status.
267 */
268 if (temp == PIPE_ISOCHRONOUS) {
269 int n, len;
270
271 /* "high bandwidth" mode, 1-3 packets/uframe? */
272 if (dev->speed == USB_SPEED_HIGH) { 
 125
273 int mult = 1 + ((max >> 11) & 0x03);
274 max &= 0x07ff;
275 max *= mult;
276 }
277
278 if (urb->number_of_packets <= 0)
279 return -EINVAL;
280 for (n = 0; n < urb->number_of_packets; n++) {
281 len = urb->iso_frame_desc[n].length;
282 if (len < 0 || len > max)
283 return -EMSGSIZE;
284 urb->iso_frame_desc[n].status = -EXDEV;
285 urb->iso_frame_desc[n].actual_length = 0; 
286 }
287 }
288
289 /* the I/O buffer must be mapped/unmapped, except when length=0 */
290 if (urb->transfer_buffer_length < 0)
291 return -EMSGSIZE;
292
293 #ifdef DEBUG
294 /* stuff that drivers shouldn't do, but which shouldn't
295 * cause problems in HCDs if they get it wrong.
296 */
297 {
298 unsigned int orig_flags = urb->transfer_flags;
299 unsigned int allowed;
300
301 /* enforce simple/standard policy */
302 allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
303 URB_NO_INTERRUPT);
304 switch (temp) {
305 case PIPE_BULK:
306 if (is_out)
307 allowed |= URB_ZERO_PACKET;
308 /* FALLTHROUGH */
309 case PIPE_CONTROL:
310 allowed |= URB_NO_FSBR; /* only affects UHCI */
311 /* FALLTHROUGH */
312 default: /* all non-iso endpoints */
313 if (!is_out)
314 allowed |= URB_SHORT_NOT_OK;
315 break;
316 case PIPE_ISOCHRONOUS: 
317 allowed |= URB_ISO_ASAP;
318 break;
319 }
320 urb->transfer_flags &= allowed;
321
322 /* fail if submitter gave bogus flags */
323 if (urb->transfer_flags != orig_flags) {
324 err("BOGUS urb flags, %x --> %x",
325 orig_flags, urb->transfer_flags);
326 return -EINVAL;
327 }
328 }
329 #endif
330 /*
331 * Force periodic transfer intervals to be legal values that are
332 * a power of two (so HCDs don't need to).
333 *
334 * FIXME want bus->{intr,iso}_sched_horizon values here. Each HC
335 * supports different values... this uses EHCI/UHCI defaults (and
336 * EHCI can use smaller non-default values).
337 */
338 switch (temp) {
339 case PIPE_ISOCHRONOUS:
340 case PIPE_INTERRUPT:
341 /* too small? */
342 if (urb->interval <= 0)
343 return -EINVAL;
344 /* too big? */
345 switch (dev->speed) {
346 case USB_SPEED_HIGH: /* units are microframes */
347 // NOTE usb handles 2^15
348 if (urb->interval > (1024 * 8))
349 urb->interval = 1024 * 8;
350 temp = 1024 * 8;
351 break;
352 case USB_SPEED_FULL: /* units are frames/msec */
353 case USB_SPEED_LOW:
354 if (temp == PIPE_INTERRUPT) {
355 if (urb->interval > 255)
356 return -EINVAL;
357 // NOTE ohci only handles up to 32
358 temp = 128;
359 } else {
360 if (urb->interval > 1024) 
361 urb->interval = 1024;
362 // NOTE usb and ohci handle up to 2^15
363 temp = 1024;
364 }
365 break;
366 default:
367 return -EINVAL;
368 }
369 /* power of two? */
370 while (temp > urb->interval)
371 temp >>= 1;
372 urb->interval = temp;
373 }
374
375 return usb_hcd_submit_urb(urb, mem_flags);375 行，将 urb 扔给 HCD，然后就进入 HCD 的片儿区了。
376 } 
```



### 中断传输

的 例子可以去看看触摸屏驱动，

### 等时传输

的可以去看看摄像头驱动，看看它们在结束处理函数 里都做了些什么，你就悟道了。



### 设备的生命线（七）

#### struct usb_hcd。



### 配置是 configuration，设置是 setting。

设备大于配置，配置大于接口，接口大于设置，更准确的说是设备可以有 多个配置，配置里可以包含一个或更多的接口，而接口通常又具有一个或更多的设置。



### minor次设备号

一般来说，主 设备号表明了设备的种类，也表明了设备对应着哪个驱动程序，而**次设备号**则是因为一个驱 动程序要支持多个设备而为了让驱动程序区分它们而设置的。**主设备号用来帮你 找到对应的驱动程序，次设备号给你的驱动用来决定对哪个设备进行操作。**



### 设备获取设备号

设备要想在 linux 里分得一个主设备号，有个立足之地，也并不是那么容易的，主设备号虽 说不是什么特别稀缺的资源，但还是需要设备先在驱动里提出申请，获得系统的批准才能拥 有一个。因为一部分的主设备号已经被静态的预先指定给了许多常见的设备，你申请的时候 要避开它们，选择一个里面没有列出来的，也就是名花还没有主的，很严肃的说，挖墙角是 很不道德的。这些已经被分配掉的主设备号都列在 Documentation/devices.txt 文件里。 当然，如果你是用动态分配的形式，就可以不去理会这些，直接让系统为你作主，替你选择 一个即可。



### usbfs

usbfs 为咱们提供了在用户空间直接访问usb硬件设备的接口，但是世界上没有免费的午餐，它需 要内核的大力支持， usbfs_driver 就是用来完成这个光荣任务的。

### USB_MAJOR

USB_MAJOR就是咱们苦苦追寻的那个她，就是linux为USB设备预留 的主设备号。事实上，前面usb_init函数的 880 行，usb_major_init函数已经使用 USB_MAJOR注册了一个字符设备，名字就叫usb。我们可以在文件/proc/devices里看到 它们。



### 分配出去的主设备号/proc/devices



### 设置

**struct usb_host_interface**

```
69 /* host-side wrapper for one interface setting's parsed descriptors */
70 struct usb_host_interface {
71 struct usb_interface_descriptor desc;
72
73 /* array of desc.bNumEndpoint endpoints associated with this
74 * interface setting. these will be in no particular order.
75 */
76 struct usb_host_endpoint *endpoint;//一个数组，表
示这个设置所使用到端点。
77
78 char *string; /* iInterface string, if present */用来保存从设备里取出来的字符串描述符信息的，既然字符串描述符可有
可无，那这里的指针也有可能为空了。
79 unsigned char *extra; /* Extra descriptors */
80 int extralen;
81 };
```



### **USB 的描述符**

设备描述符，配置描述符， 接口描述符和端点描述符，协议里规定一个 usb 设备是必须支持这四大描述符的，当然也 有其它一些描述符来让设备可以显得个性些，但这四大描述符是一个都不能少的。

usb 设备里都会有一个叫 EEPROM 的东东，没错，**USB 的描述符**就是放在它那儿，它就是用来存储设备 本身信息的。



### Flash与ROM

电可擦写的可编程 ROM，它与 Flash 虽说都是要电擦除的，但它可以按字节擦除，Flash 只能一次擦除一个 block，所以如果要改动比较少的数据的话，使用它还是比较合适的，但 是世界上没有完美的东西，此物成本相对 Flash 比较高，所以一般来说 usb 设备里只拿它 来存储一些本身特有的信息，要想存储数据，还是用 Flash 吧



### 接口描述符

它当然就是描述接口本身的信息的。一个接口可以有多个设置，使用不 同的设置，描述接口的信息会有些不同，所以接口描述符并没有放在 struct usb_interface 结构里，而是放在表示接口设置的 struct usb_host_interface 结构里。定义在 include/linux/usb/ch9.h 文件里

```
294 /* USB_DT_INTERFACE: Interface descriptor */
295 struct usb_interface_descriptor {
296 __u8 bLength; //，描述符的字节长度。协议里规定，每个描述符必须以一个字节打头来
表明描述符的长度。那可以扳着指头数一下，接口描述符的 bLength 应该是 9，两个巴掌
就数完了，没错，ch9.h 文件里紧挨着接口描述符的定义就定义了这个长度
297 __u8 bDescriptorType;bDescriptorType，描述符的类型。各种描述符的类型都在ch9.h文件里有定义，
对应spec 中的Table 9.5。对于接口描述符来说，值为 USB_DT_INTERFACE，也就是
0x04。
298
299 __u8 bInterfaceNumber; //，接口号。每个配置可以包含多个接口，这个值就是它们的
索引值。
300 __u8 bAlternateSetting;//接口使用的是哪个可选设置。协议里规定，接口默认使用的
设置总为 0 号设置。
301 __u8 bNumEndpoints;//接口拥有的端点数量。这里并不包括端点 0，端点 0 是所有
的设备都必须提供的，所以这里就没必要多此一举的包括它了。
302 __u8 bInterfaceClass;
303 __u8 bInterfaceSubClass;//bInterfaceClass，303 行 bInterfaceSubClass，304 行 bInterfaceProtocol。
这个世界上有许许多多的 usb 设备，它们各有各的特点，为了区分它们，usb 规范，或者
说 usb 协议，把 usb 设备分成了很多类，然而每个类又分成子类，这很好理解，我们一个
大学也是如此，先是分成很多个学院，然后每个学院又被分为很多个系，然后可能每个系下
边又分了各个专业，usb协议也是这样干的，首先每个Device或Interface属于一个Class，
然后 Class 下面又分了 SubClass，完了 SubClass 下面又按各种设备所遵循的不同的通信
协议继续细分。usb 协议里边为每一种 Class，每一种 SubClass，每一种 Protocol 定义
一个数值，比如 mass storage 的 Class 就是 0x08，hub 的 Class 就是 0x09
304 __u8 bInterfaceProtocol;
305 __u8 iInterface;
306 } __attribute__ ((packed)); //意思就是
告诉编译器，这个结构的元素都是 1 字节对齐的，不要再添加填充位了。因为这个结构和
spec里的Table 9.12 是完全一致的，包括字段的长度，如果不给编译器这么个暗示，编译
器就会依据你平台的类型在结构的每个元素之间添加一定的填充位，如果你拿这个添加了填
充位的结构去向设备请求描述符，你想想会是什么结果。
```

![image-20210401202615734](/home/zhaoyong/.config/Typora/typora-user-images/image-20210401202615734.png)	

### 端点

```
59 struct usb_host_endpoint {
60 struct usb_endpoint_descriptor desc;/端点描述符，四大描述符的第二个隆重登场了。
61 struct list_head urb_list;//端点要处理的urb队列。urb是什么？
这年头儿钱不多就是新名词儿多，是个新名词爆炸的时代，不过urb可是usb通信的主角，
它包含了执行urb传输所需要的所有信息，你要想和你的usb通信，就得创建一个urb，并
且为它赋好值，交给咱们的usb core，它会找到合适的host controller，从而进行具体的
数据传输。设备中的每个端点都可以处理一个urb队列，当然，urb是内核里对usb传输数
据的封装也叫抽象吧，协议里可不这么叫。基于urb特殊的江湖地位，接下来的哪一个黄道
吉日里，我会对它大书特书的。
62 void *hcpriv;//这是提供给 HCD（host controller driver）用的。比如等时端点会在里
边儿放一个 ehci_iso_stream，
63 struct ep_device *ep_dev; /* For sysfs info */
64
65 unsigned char *extra; /* Extra descriptors */
66 int extralen;
67 }; 
```

端点描述符

```
312 /* USB_DT_ENDPOINT: Endpoint descriptor */
313 struct usb_endpoint_descriptor {
314 __u8 bLength;
315 __u8 bDescriptorType; //描述符类型，这里对于端点就是 USB_DT_ENDPOINT，0x05。
316
317 __u8 bEndpointAddress;//这个字段描述的信息挺多的，比如这个端点是输入端点还
是输出端点，这个端点的地址，以及这个端点的端点号。它的bits 0~3 表示的就是端点号，
你使用 0x0f和它相与就可以得到端点号。不过，开发内核的同志想的都很周到，定义好了
一个掩码USB_ENDPOINT_NUMBER_MASK，它的值就是 0x0f，当然，这是为了让咱们
更容易去读他们的代码，也为了以后的扩展。另外，它的bit 8 表示方向，输入还是输出，
同样有掩码 USB_ENDPOINT_DIR_MASK，值为 0x80，将它和bEndpointAddress相
与，并结合USB_DIR_IN和USB_DIR_OUT作判断就可以得到端点的方向。
318 __u8 bmAttributes;//bmAttributes，属性，总共 8 位，其中bit1 和bit0 共同称为Transfer Type,即
传输类型， 00 表示控制，01 表示等时，10 表示批量，11 表示中断。前面的端点号还
有端点方向都有配对儿的掩码，这里当然也有，就在struct usb_endpoint_descriptor定
义的下面
338 #define USB_ENDPOINT_XFERTYPE_MASK 0x03 /* in bmAttributes */
339 #define USB_ENDPOINT_XFER_CONTROL 0
340 #define USB_ENDPOINT_XFER_ISOC 1
341 #define USB_ENDPOINT_XFER_BULK 2
342 #define USB_ENDPOINT_XFER_INT 3 

319 __le16 wMaxPacketSize;//端点一次可以处理的最大字节数。比如你老板比较看重你，
一次给你交代了几个任务，于是你大声的疾呼，神啊，我一次只能做一个，当然神是听不到
的，怎么办那，加班加点儿，一个一个的分开做呗。端点也是，如果你发送的数据量大于端
点的这个值，也会分成多次一次一次来传输。友情提醒一下，这个字段还是有点门道的，对
不同的传输类型也有不同的要求，日后碰到了再说。
320 __u8 bInterval;//USB 是轮询式的总线，这个值表达了端点一种美好的期待，希望主
机轮询自己的时间间隔，但实际上批准不批准就是 host 的事了。不同的传输类型 bInterval
也有不同的意义，暂时就提这么一下，碰到各个实际的传输类型了再去说它。不是俺捂盘惜
售，而是初次照面儿就对人家寻根问底的不大礼貌，这里先留个印象，有缘总会再相见的。
321
322 /* NOTE: these two are _only_ in audio endpoints. */
323 /* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */
324 __u8 bRefresh;
325 __u8 bSynchAddress;
326 } __attribute__ ((packed));
327
328 #define USB_DT_ENDPOINT_SIZE 7
329 #define USB_DT_ENDPOINT_AUDIO_SIZE 9 /* Audio extension */ 
```

page 49



### 设备的状态

```
557 enum usb_device_state {
558 /* NOTATTACHED isn't in the USB spec, and this state acts
559 * the same as ATTACHED ... but it's clearer this way.
560 */
561 USB_STATE_NOTATTACHED = 0,//Attached 表示设备已经连接到 usb 接口上了，是 hub 检测到设备时的初始状态。那么这
里所谓的 USB_STATE_NOTATTACHED 就是表示设备并没有 Attached
562 
 55
563 /* chapter 9 and authentication (wireless) device states */
564 USB_STATE_ATTACHED,
565 USB_STATE_POWERED, /* wired */Powered 是加电状态。USB 设备的电源可以来自外部电源，协议里叫做 self-powered，
也可以来自 hub，叫 bus-powered。尽管 self-powered 的 USB 设备可能在连接上 USB
接口以前已经上电，但它们直到连上 USB 接口后才能被看作是 Powered 的，你觉得它已
经上电了那是站在你的角度看，可是现在你看的是 usbcore，所以要放弃个人的成见，团
结在 core 的周围。
566 USB_STATE_UNAUTHENTICATED, /* auth */
567 USB_STATE_RECONNECTING, /* auth */
568 USB_STATE_DEFAULT, /* limited function */缺省状态，在 Powered 之后，设备必须在收到一个复位（reset）信号并成功复
位后，才能使用缺省地址回应主机发过来的设备和配置描述符的请求。
569 USB_STATE_ADDRESS,//表示主机分配了一个唯一的地址给设备，此时设备可以使用缺省管道响应主
机的请求。真羡慕这些 usb 设备，住的地方都是包分配的，哪像咱们辛辛苦苦一路小跑着
也不一定能达到 Address 状态。
570 USB_STATE_CONFIGURED, /* most functions */状态表示设备已经被主机配置过了，也就是协议里说的处理了一个带有非 0 值
的 SetConfiguration()请求，此时主机可以使用设备提供的所有功能。
571
572 USB_STATE_SUSPENDED挂起状态，为了省电，设备在指定的时间内，3ms 吧，如果没有发生总线传
输，就要进入挂起状态。此时，usb 设备要自己维护包括地址、配置在内的信息。
573
574 /* NOTE: there are actually four different SUSPENDED
575 * states, returning to POWERED, DEFAULT, ADDRESS, or
576 * CONFIGURED respectively when SOF tokens flow again.
577 */
578 };
上面定义了 9 种状态，spec 里只定义了 6 种，Attached，Powered，Default，Address，
Configured，Suspended，对应于 Table 9.1。
```



### 设备的速度

地球人都知道，USB 设备有三种速度，低速，全速，高速。USB1.1 那会儿只有低速，全 速，后来才出现了高速，就是所谓的 480Mbps/s。这里还有个 USB_SPEED_VARIABLE， 是无线 USB 的，号称 usb 2.5，还在发展中，据说小黑的 T61 已经支持了，向往 ing。 USB_SPEED_UNKNOWN 只是表示现阶段还不知道这个设备究竟什么速度。

```
548 /* USB 2.0 defines three speeds, here's how Linux identifies them */
549
550 enum usb_device_speed {
551 USB_SPEED_UNKNOWN = 0, /* enumerating */
552 USB_SPEED_LOW, USB_SPEED_FULL, /* usb 1.1 */
553 USB_SPEED_HIGH, /* usb 2.0 */
554 USB_SPEED_VARIABLE, /* wireless (usb 2.5) */
555 }; 
```

**SYNC 同步字段**

所有的 packets 都从一个 SYNC 同步字段开始，SYNC 是一个 8 位长的二进制串，只是用来同步用的，它的最后两位标志了 SYNC 的结束和 PID （Packet Identifer）的开始，就像咱们的大四标志了梦想的结束和现实的开始。PID 也是 一个 8 位的二进制串，前四位用来区分不同的 packet 类型，后面四位只是前四位的反码， 校验用的。

主机和设备都是纯理性的东东，完全通过 PID 来判断送过来的 packet 是不是自己所需要 的，不像咱们，往往缺乏这么一个用来判断的标准，不知道自己究竟需要的是什么。PID 之 后紧跟着的是地址字段，每个 packet 都需要知道自己要往哪里去，它们是一个一个目的明 确的精灵，行走在 usb cable 里，而我们的前方在哪里？这个地址实际上包括两部分，7 位表示了总线上连接的设备或接口的地址，4 位表示端点的地址，这就是为什么前面说每条usb 总线最多只能有 128 个设备，即使是高速设备除了 0 号端点也最多只能有 15 个 in 端 点和 15 个 out 端点。地址字段再往后是 11 位的帧号（frame number），值达到 7FFH 时归零，像一个个无聊的夜晚一样循环往复。这个帧号并不是每一个 packet 都会有，它只 在每帧或微帧（Mircoframe）开始的 SOF Token 包里发送。帧是对于低速和全速模式来 说的，一帧就是 1ms，对于高速模式的称呼是微帧，一个微帧为 125 微妙，每帧或微帧当 然不会只能传一个 packet。帧号再往后就是千呼万唤始出来的 Data 字段了，它可以有 0 到 1024 个字节不等。最后还有 CRC 校验字段来做扫尾工作。



### PID

（Packet Identifer）PID 也是 一个 8 位的二进制串，前四位用来区分不同的 packet 类型，后面四位只是前四位的反码， 校验用的。



### packet 的类型

**Table 8-1**

![image-20210402131542464](/home/zhaoyong/.config/Typora/typora-user-images/image-20210402131542464.png)	



### toggle

咱们要学习 packet，做一个有理想有目标的人，所以这里只看看 Data 类型的 packet。前 面的 Table 8-1 里显示，有四种类型的 Data 包，DATA0，DATA1，DATA2 和 MDATA。 存在就是有价值的，这里分成 4 种数据包自然有里面的道理，其中 DATA0 和 DATA1 就可 以用来实现 data toggle 同步，看到 toggle，好像有点接近不久之前留下的疑问了。 对于批量传输、控制传输和中断传输来说，数据包最开始都是被初始化为 DATA0 的，然后 为了传输的正确性，就一次传 DATA0，一次传 DATA1，一旦哪次打破了这种平衡，主机就 可以认为传输出错了。对于等时传输来说，**data toggle** 并不被支持。USB 就是在使用这 种简单的哲学来判断对于错。	

我们的 struct usb_device 中的数组 unsigned int toggle[2]就是为了支持这种简单的哲 学而生的，它里面的每一位表示的就是每个端点当前发送或接收的数据包是 DATA0 还是 DATA1。



### 四大描述符

![image-20210403171354120](/home/zhaoyong/.config/Typora/typora-user-images/image-20210403171354120.png)	



### 设备描述符

```
203 /* USB_DT_DEVICE: Device descriptor */
204 struct usb_device_descriptor {
205 __u8 bLength;//描述符的长度
206 __u8 bDescriptorType;//这里对于设备描述符应该是 USB_DT_DEVICE，0x01。
207
208 __le16 bcdUSB;//USB spec 的版本号，一个设备如果能够进行高速传输，那么它设备描
述符里的 bcdUSB 这一项就应该为 0200H。
209 __u8 bDeviceClass;
210 __u8 bDeviceSubClass;
211 __u8 bDeviceProtocol;
212 __u8 bMaxPacketSize0;//端点 0 一次可以处理的最大字节数，端点 0 的属性却放到
设备描述符里去了，
213 __le16 idVendor;
214 __le16 idProduct;
分别是厂商和产品的 ID。
215 __le16 bcdDevice;//设备的版本号。
216 __u8 iManufacturer;
217 __u8 iProduct;
218 __u8 iSerialNumber;
分别是厂商，
产品和序列号对应的字符串描述符的索引值。

219 __u8 bNumConfigurations;
，设备当前速度模式下支持的配置数量。有的设备可以在
多个速度模式下操作，这里包括的只是当前速度模式下的配置数目，不是总的配置数目。

220 } __attribute__ ((packed));
221
222 #define USB_DT_DEVICE_SIZE 18 
```



### 端点0

```
前面说端点的时候说了端点 0 并没有一个专门的端点描述符，因为不需要，基本上它所有
的特性都在 spec 里规定好了的，然而，别忘了这里说的是“基本上”，有一个特性则是不
 60
一样的，这叫做 maximum packet size，每个端点都有这么一个特性，即告诉你该端点
能够发送或者接收的包的最大值。对于通常的端点来说，这个值被保存在该端点描述符中的
wMaxPacketSize 这一个 field，而对于端点 0 就不一样了，由于它自己没有一个描述符，
而每个设备又都有这么一个端点，所以这个信息被保存在了设备描述符里，所以我们在设备
描述符里可以看到这么一项，bMaxPacketSize0。而且 spec 还规定了，这个值只能是 8，
16，32 或者 64 这四者之一，如果一个设备工作在高速模式，这个值还只能是 64，如果
是工作在低速模式，则只能是 8，取别的值都不行。
```



### USB 的设备请求

（device request）。协议里说了，所有的设备通过缺省的控制管道来响应主机的请求，既然使用的 是控制管道，那当然就是控制传输了，这些请求的底层 packet 属于 Setup 类型，前面的 那张表里也可以看到它，在 Setup 包里包括了请求的各种参数。协议里同时也定义了一些 标准的设备请求，并规定所有的设备必须响应它们，即使它们还处于 Default 或 Address 61 状态。这些标准的设备请求里，GET_DESCRIPTOR 就赫然在列。



### 设备

### struct usb_device

```
336 struct usb_device {
337 int devnum; /* Address on USB bus */设备的地址。此地址非彼地址，和咱们写程序时说的地址是不一样的，
devnum 只是 usb 设备在一条 usb 总线上的编号。
338 char devpath [16]; /* Use in messages: /port/port/... */
localhost:~ # ls /sys/bus/usb/devices/
1-0:1.0 2-1 2-1:1.1 4-0:1.0 4-5:1.0 usb2 usb4
2-0:1.0 2-1:1.0 3-0:1.0 4-5 usb1 usb3 
4 号 Root Hub，0 就是这里我们说的 devpath，1 表示配置为 1
号，0 表示接口号为 0。
4-0:1.0
4 号总线的 0 号端口的设备，使用的是 1 号配置，接口
号为0

339 enum usb_device_state state; /* configured, not attached, etc */设备的状态。这是个枚举类型
340 enum usb_device_speed speed; /* high/full/low (or error) */设备的速度，这也是个枚举变量
341
342 struct usb_tt *tt; /* low/full speed dev, highspeed hub
*/
343 int ttport; /* device port on that tt hub */ 
 52342 行，tt，343 行，ttport。知道 tt 干嘛的吗？tt 叫做 transaction translator。你可
以把它想成一块特殊的电路，是 hub 里面的电路，确切的说是高速 hub 中的电路，我们知
道 usb 设备有三种速度的，分别是 low speed，full speed，high speed。即所谓的低速
/全速/高速，抗日战争那会儿，这个世界上只有 low speed/full speed 的设备，没有 high
speed 的设备，后来解放后，国民生产力的大幅度提升催生了一种 high speed 的设备，
包括主机控制器，以前只有两种接口的，OHCI/UHCI，这都是在 usb spec 1.0 的时候，
后来 2.0 推出了 EHCI，高速设备应运而生。Hub 也有高速 hub 和过去的 hub，但是这里
就有一个兼容性问题了，高速的 hub 是否能够支持低速/全速的设备呢？一般来说是不支持
的，于是有了一个叫做 TT 的电路，它就负责高速和低速/全速的数据转换，于是，如果一
个高速设备里有这么一个 TT，那么就可以连接低速/全速设备，如不然，那低速/全速设备
没法用，只能连接到 OHCI/UHCI 那边出来的 hub 口里。
344
345 unsigned int toggle[2]; /* one bit for each endpoint
346 * ([0] = IN, [1] = OUT) */这个数组只有两个元素，分别对应 IN 和 OUT 端点，每一个端点占
一位。
347
348 struct usb_device *parent; /* our hub, unless we're the root */，parent，struct usb_device 结构体的 parent 自然也是一个 struct usb_device
指针。对于 Root Hub，前面说过，它是和 Host Controller 是绑定在一起的，它的 parent
指针在 Host Controller 的驱动程序中就已经赋了值，这个值就是 NULL，换句话说，对于
Root Hub，它不需要再有父指针了，这个父指针就是给从 Root Hub 连出来的节点用的。
USB 设备是从 Root Hub 开始，一个一个往外面连的，比如 Root Hub 有 4 个口，每个口
连一个 USB 设备，比如其中有一个是 Hub，那么这个 Hub 有可以继续有多个口，于是一
级一级的往下连，最终连成了一棵树。
349 struct usb_bus *bus; /* Bus we're part of */设备所在的那条总线
350 struct usb_host_endpoint ep0;/ep0，端点 0 的特殊地位决定了她必将受到特殊的待遇，在 struct usb_device
对象产生的时候它就要初始化。
351
352 struct device dev; /* Generic device interface */嵌入到 struct usb_device 结构里的 struct device 结构。
353
354 struct usb_device_descriptor descriptor;/* Descriptor */
355 struct usb_host_config *config; /* All of the configs */
356
357 struct usb_host_config *actconfig;/* the active configuration */
355 行，config，357 行，actconfig，分别表示设备拥有的所有配置和当前激活的，也就
是正在使用的配置。usb设备的配置用struct usb_host_config结构来表示，下节再说。

358 struct usb_host_endpoint *ep_in[16];
359 struct usb_host_endpoint *ep_out[16];
360
ep_in[16]，359 行，ep_out[16]，除了端点 0，一个设备即使在高速模式下也
最多只能再有 15 个 IN 端点和 15 个 OUT 端点，端点 0 太特殊了，对应的管道是 Message
管道，又能进又能出特能屈能伸的那种，所以这里的 ep_in 和 ep_out 数组都有 16 个值。
361 char **rawdescriptors; /* Raw descriptors for each config */
这是个字符指针数组，数组里的每一项都指向一个使用
GET_DESCRIPTOR 请求去获得配置描述符时所得到的结果。考虑下，为什么我只说得到
的结果，而不直接说得到的配置描述符？不是请求的就是配置描述符么？这是因为你使用
GET_DESCRIPTOR 去请求配置描述符时，设备返回给你的不仅仅只有配置描述符，它把
该配置所包括的所有接口的接口描述符，还有接口里端点的端点描述符一股脑的都塞给你
了。第一个接口的接口描述符紧跟着这个配置描述符，然后是这个接口下面端点的端点描述
符，如果有还有其它接口，它们的接口描述符和端点描述符也跟在后面，这里面，专门为一
类设备定义的描述符和厂商定义的描述符跟在它们对应的标准描述符后面。这和我们去买水
果，买了 5 斤苹果却只有 5 个真实天壤之别，现实生活中的愤懑在 USB 世界里得到了发泄。
362
363 unsigned short bus_mA; /* Current available from the bus */这个值是在 host controller 的驱动程序中设置的，通常来讲，计算机
的 usb 端口可以提供 500mA 的电流。
364 u8 portnum; /* Parent port number (origin 1) */不管是 root hub 还是一般的 hub，你的 USB 设备总归要插在一个
hub 的端口上才能用，portnum 就是那个端口号。当然，对于 root hub 这个 usb 设备来
说它本身没有 portnum 这么一个概念，因为它不插在别的 Hub 的任何一个口上。所以对
于 Root Hub 来说，它的 portnum 在 Host Controller 的驱动程序里给设置成了 0。
365 u8 level; /* Number of USB hub ancestors */层次，也可以说是级别，表征 usb 设备树的级连关系。Root Hub 的 level
当然就是 0，其下面一层就是 level 1，再下面一层就是 level 2，依此类推。
366
367 unsigned discon_suspended:1; /* Disconnected while suspended */
368 unsigned have_langid:1; /* whether string_langid is valid */have_langid，369 行，string_langid，usb 设备里的字符串描述符使用的是
UNICODE 编码，可以支持多种语言，string_langid 就是用来指定使用哪种语言的，
have_langid 用来判断 string_langid 是否有效。
369 int string_langid; /* language ID for strings */
370
371 /* static strings from the device */
372 char *product; /* iProduct string, if present */
373 char *manufacturer; /* iManufacturer string, if present */
374 char *serial; /* iSerialNumber string, if present */
372 行，product，373 行，manufacturer，374 行，serial，分别用来保存产品、厂商
和序列号对应的字符串描述符信息。

375
376 struct list_head filelist;
377 #ifdef CONFIG_USB_DEVICE_CLASS
378 struct device *usb_classdev;
379 #endif
380 #ifdef CONFIG_USB_DEVICEFS
381 struct dentry *usbfs_dentry; /* usbfs dentry entry for the device
*/
382 #endif //usbfs 相关的，不可知的未来说 usbfs 的时候再聊它们。
383 /*
384 * Child devices - these can be either new devices
385 * (if this is a hub device), or different instances
386 * of this same device. 
 53
387 *
388 * Each instance needs its own set of data structures.
389 */
390
391 int maxchild; /* Number of ports if hub */，maxchild，hub 的端口数，注意可不包括上行端口。
392 struct usb_device *children[USB_MAXCHILDREN];//children[USB_MAXCHILDREN] ， USB_MAXCHILDREN 是
include/linux/usb.h 里定义的一个宏，值为 31 
 #define USB_MAXCHILDREN (31)
其实 hub 可以接一共 255 个端口，不过实际上遇到的 usb hub 最多的也就是说自己支持
10 个端口的，所以 31 基本上够用了。
393
394 int pm_usage_cnt; /* usage counter for autosuspend */
395 u32 quirks; /* quirks of the whole device */总之这里的 quirk 就是用来判断这些有毛病的
产品啥毛病的。谁去判断？不像咱们的中国足协，把中国足球折腾成这样子，也就是出来声
明一下完事儿，咱们 usb 这儿实行的可是责任制，你的设备接哪儿哪儿负责，也就是说 hub
去判断，就不用咱费心了。
396
397 #ifdef CONFIG_PM ，我们就知道从这里直到最后的那个#endif
都是关于电源管理的。让我们先大胆的忽略它们
398 struct delayed_work autosuspend; /* for delayed autosuspends */
399 struct mutex pm_mutex; /* protects PM operations */
400
401 unsigned long last_busy; /* time of last use */
402 int autosuspend_delay; /* in jiffies */
403
404 unsigned auto_pm:1; /* autosuspend/resume in progress */
405 unsigned do_remote_wakeup:1; /* remote wakeup should be enabled */
406 unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
407 unsigned autoresume_disabled:1; /* disabled by the user */
408 #endif
409 }; 
```



### usb 子系统里面关于地址的游戏规则

在 usb 世界里，一条总线就是大树 一棵，一个设备就是叶子一片。为了记录这棵树上的每一个叶子节点，每条总线设有一个地 址映射表，即 struct usb_bus 结构体里有一个成员 struct usb_devmap devmap

```
268 /* USB device number allocation bitmap */
269 struct usb_devmap {
270 unsigned long devicemap[128 / (8*sizeof(unsigned long))];
271 }; 
上面的 devmap 地址映射表就表示了一条总线上设备连接的情况，假设 unsigned
long=4bytes，那么 unsigned long devicemap[128/(8*sizeof(unsigned long)]]就
等价于 unsigned long devicemap[128/(8*4)] ，进而等价于 unsigned long
devicemap[4]，而 4bytes 就是 32 个 bits，因此这个数组最终表示的就是 128 个 bits。
而这也对应于一条总线可以连接 128 个 usb 设备。之所以这里使用 sizeof(unsigned
long)，就是为了跨平台应用，不管 unsigned long 到底是几，总之这个 devicemap 数组
最终可以表示 128 位，也就是说每条总线上最多可以连上 128 个设备
```



### 什么是usb_bus？

```
前面不是已经有了一个struct bus_type类型的 usb_bus_type了么？
没错，在usb子系统的初始化函数usb_init里已经注册了 usb_bus_type，不过那是让系统
 54
知道有这么一个类型的总线。而一个总线类型和一条总线是两码子事儿。从硬件上来讲，一
个host controller就会连出一条usb总线，而从软件上来讲，不管你有多少个host
controller，或者说有多少条总线，它们通通属于usb_bus_type这么一个类型，只是每一
条总线对应一个struct usb_bus结构体变量，这个变量在host controller的驱动程序中去
申请。
```



### 配置描述符

```
258 struct usb_config_descriptor {
259 __u8 bLength;//描述符的长度，值为 USB_DT_CONFIG_SIZE。
260 __u8 bDescriptorType;//bDescriptorType，描述符的类型，值为 USB_DT_CONFIG，0x02。这么说对
不对？按照前面接口描述符、端点描述符和设备描述符的习惯来说，应该是没问题。但是，
生活总是会在我们已经习惯它的时候来个转折，这里的值却并不仅仅可以为
USB_DT_CONFIG，还可以为USB_DT_OTHER_SPEED_CONFIG，0x07。这里说的
OTHER_SPEED_CONFIG描述符描述的是高速设备操作在低速或全速模式时的配置信息，
和配置描述符的结构完全相同，区别只是描述符的类型不同，是只有名字不同的孪生兄弟。
261
262 __le16 wTotalLength;//使用 GET_DESCRIPTOR 请求从设备里获得配置描述符信息时，
返回的数据长度，也就是说对包括配置描述符、接口描述符、端点描述符，class-或
vendor-specific 描述符在内的所有描述符算了个总帐。
263 __u8 bNumInterfaces;//这个配置包含的接口数目。
264 __u8 bConfigurationValue;对于拥有多个配置的幸运设备来说，可以拿这个值为参
数，使用 SET_CONFIGURATION 请求来改变正在被使用的 USB 配置，
bConfigurationValue 就指明了将要激活哪个配置。咱们的设备虽然可以有多个配置，但
 65
同一时间却也只能有一个配置被激活。捎带着提一下，SET_CONFIGURATION 请求也是
标准的设备请求之一，专门用来设置设备的配置。
265 __u8 iConfiguration;//描述配置信息的字符串描述符的索引值。
266 __u8 bmAttributes;这个字段表征了配置的一些特点，比如 bit 6 为 1 表示
self-powered，bit 5 为 1 表示这个配置支持远程唤醒。另外，它的 bit 7 必须为 1，为什
么？协议里就这么说的，我也不知道，这个世界上并不是什么事情都找得到原因的。
267 __u8 bMaxPower;//设备正常运转时，从总线那里分得的最大电流值，以 2mA 为单位。
设备可以使用这个字段向 hub 表明自己需要的的电流，但如果设备需求过于旺盛，请求的
超出了 hub 所能给予的，hub 就会直接拒绝，不会心软。你去请求她给你多一点点爱，可
她心系天下人，没有多的分到你身上，于是怎么办？拒绝你呗，不要说爱情是多么残酷，这
个世界就是很无奈。还记得 struct usb_device 结构里的 bus_mA 吗？它就表示 hub 所
能够给予的。
268 } __attribute__ ((packed));
269
270 #define USB_DT_CONFIG_SIZE 
```



### usb 接 口的缓存

为了在配置被取 代之后仍然能够获取它的一些信息，就把日后可能会需要的一些东东放在了intf_cache数 组的struct usb_interface_cache对象里。谁会需要？这么说吧，你通过sysfs这个窗口 只能看到设备当前配置的一些信息，即使是这个配置下面的接口，也只能看到接口正在使用 的那个可选设置的信息，可是你希望能够看到更多的，怎么办，窗户太小了，可以趴门口看， usbfs就是这个门，里面显示有你的系统中所有usb设备的可选配置和端点信息，它就是利 用intf_cache这个数组里缓存的东东实现的。

```
193 struct usb_interface_cache {
194 unsigned num_altsetting; /* number of alternate settings */
195 struct kref ref; /* reference counter */
196
197 /* variable-length array of alternate settings for this interface,
198 * stored in no particular order */
199 struct usb_host_interface altsetting[0];//是一个可变长数组，按需分配的那种，你对设备说
GET_DESCRIPTOR 的时候，内核就根据返回的每个接口可选设置的数目分配给
intf_cache数组相应的空间，有多少需要多少分配多少，在咱们还在为拥有一套房而奋斗
终生的时候，这里已经提前步入了共产主义。
200 }; 
```



### 配置

```
244 struct usb_host_config {
245 struct usb_config_descriptor desc;
246
247 char *string; /* iConfiguration string, if present */ 这个字符串保存了配置描述符iConfiguration字段对应的字符串描述
符信息。
248 /* the interfaces associated with this configuration,
249 * stored in no particular order */
250 struct usb_interface *interface[USB_MAXINTERFACES];//配置所包含的接口。注释里说的很明确，
这个数组的顺序未必是按照配置里接口号的顺序，所以你要想得到某个接口号对应的struct
usb_interface 结构对象，就必须使用 usb.c 里定义的 usb_ifnum_to_if 函数。
251
252 /* Interface information available even when this is not the
253 * active configuration */
254 struct usb_interface_cache *intf_cache[USB_MAXINTERFACES];//是 include/linux/usb.h 里定义的一个宏，值为 32，不要说不
够用，谁见过有很多接口的设备
就是 usb 接口的缓存。
255
256 unsigned char *extra; /* Extra descriptors */
257 int extralen;
256 行 ， extra ， 257 行 ， extralen ，有关额外扩展的描述符的，和 struct
usb_host_interface 里的差不多，只是这里的是针对配置的，如果你使用
GET_DESCRIPTOR请求从设备里获得配置描述符信息，它们会紧跟在标准的配置描述符
后面返回给你。
258 }; 
```



### 得到某个接口号对应的struct usb_interface 结构对象

```
84 struct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,
85 unsigned ifnum)
86 {
87 struct usb_host_config *config = dev->actconfig;
88 int i;
89
90 if (!config)
91 return NULL;
92 for (i = 0; i < config->desc.bNumInterfaces; i++)
93 if (config->interface[i]->altsetting[0]
94 .desc.bInterfaceNumber == ifnum)
95 return config->interface[i];
96
97 return NULL;
98 }
这个函数的道理很简单，就是拿你指定的接口号，和当前配置的每一个接口可选设置 0 里
的接口描述符的 bInterfaceNumber 字段做比较，相等了，那个接口就是你要寻找的，都
不相等，那对不起，不能满足你的要求，虽然它已经尽力了。
```

