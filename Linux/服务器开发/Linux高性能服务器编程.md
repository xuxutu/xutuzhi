# Linux高性能服务器编程

## 前言

### 大师级别的书

​	整本书只关注于一个问题，而且对每个技术细节的描述都精雕细琢。最关键的是，我们在阅读这些经典书籍时，似乎实在用心与一位编程高手交流。这绝对是一种享受。



## 第一章 TCP/IP协议族

### 1.1 TCP/IP协议族体系结构以及主要协议

​	**TCP/IP协议族是一个四层协议系统**。上层协议使用下层协议提供的服务。

![image-20210603153452436](Linux高性能服务器编程.assets/image-20210603153452436.png)	



#### 1.1.1 数据链路层

​	**数据链路层**实现了**网卡接口**的**网络驱动程序**，以处理数据在物理媒介（以太网、令牌环）上的传输。不同的物理网络有不同的电气特性，网卡驱动程序隐藏了这些细节，为上层协议提供一个统一的接口。

​	数据链路层常用的协议是ARP协议（Address reslove Protocol，地址解析协议 ）和RARP协议（Rerverse Address reslove Protocol，逆地址解析协议 ）。**它们实现了IP地址与机器物理地址（MAC地址）的相互转换。**

​	网络层通过IP地址寻找一台机器，而数据链路层通过mac地址寻找一台机器，因此网络层必须先将IP地址转为物理地址，才能使用数据链路层提供的服务，这就**是ARP协议的用途**。RARP协议仅用于网络上的某些无盘工作站。以内缺乏存储设备，无盘工作站无法记住自己的IP地址，但是它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射，



#### 1.1.2 网络层

​	**网络层实现数据包的选路和转发。**WAN（Wide Area Network， 广域网）通常使用众多分级的路由器来连接分散的主机或LAN（Local Area Network， 局域网）因此通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的。**网络层的任务就是选择这些中间节点，以确定两台机器之间的通信路径**。**同时网络层对上层协议隐藏了网络拓扑连接的细节，使得传输层和上层应用程序来看，两台机器是直接向连的**，

​	网络层最核心的协议是**IP协议**（Internet Protocol，因特网协议）。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发给目标主机，那么IP协议就为它寻找一个合适的下一跳（next hop）路由器，并将数据交付给该路由器来转发。多次重复这一过程，数据最终达到目标主机，或者由于发送失败而被丢弃。可见，**IP协议通过逐跳的（hop by hop）方式来来确定通信路径**。

​	网络层的另一个重要的协议是**ICMP协议**（Internet Control message Protocol，因特网控制报文协议）。它是IP协议的重要补充，主要用于检测网络连接。ICMP使用的报文格式如图：

![image-20210603161554266](Linux高性能服务器编程.assets/image-20210603161554266.png)

上图，**八位类型字段**用于区分报文类型。它将ICMP报文分为两大类：一类是差错报文，这类报文主要是用来回应网络错误，比如目标不可到达（类型值为3），和重定向（类型值为5）;另一类是查询报文，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查看目标是否可到达的（类型值为8）。有的ICMP还使用**八位代码字段**来进一步细分不同的条件。比如重定向报文使用代码值0表示对网络重定向，代码值为1代表对主机重定向。ICMP报文使用16为校验和字段对整个报文（包括头部和内容部分）进行循环冗余校验（Cyclik Redundancy Check，CRC），以检验报文在传输过程中是否损坏。不同的ICMP报文类型具有不同的正文内容。

需要指出的是，ICMP协议并不属于严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（一般来说上层协议使用下层协议提供的服务）。



#### 1.1.3 传输层

![](Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20210709171738838.png)	

传输层为两台主机提供端到端(end to end)的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。图1-3展示了传输层和网络层的这种区别。

##### 1.1.3.1 各层的封装

可见，数据链路层(驱动程序)封装了物理网络的电气细节；网络层封装了网络连接的细节；传输层则为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连等。

传输层主要协议有三个：**TCP协议**、**UDP**协议和**SCTP**协议。

TCP协议为应用层提供**可靠的**、**面向连接**的、**基于流**的服务。TCP协议使用**超时重传**、**数据确认**等方式来**确保数据包被正确地发送到目的端**，因此TCP服务是可靠的。使用TCP协议通信的双方必须建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如**连接的状态**、**读写缓冲区**，以及**诸多定时器**等。当通信结束时，双方必须关闭连接以释放这些内核数据。

##### 1.1.3.2 基于流的特点

**TCP服务**是基于流的。**基于流的数据没有边界限制**，它源源不断地从**通信的一端流入流入另一端**。发送端可以逐个字节地向数据流中写入数据，接收端可以逐个字节地将它们读出。

**UDP协议**则与TCP协议完全相反，它为应用层提供不可靠、无连接、基于数据报的服务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传输到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则**UDP协议只是简单地通知应用程序发送失败**。因此，使用UDP协议的应用程序通常需要自己处理数据确认、超时重传等逻辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。基于数据报的服务，是相当于流的服务而言的。**每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则，数据将被截断。**

SCTP协议（流控制传输协议）是一种相对较新的传输协议，它是为了在因特网上传输电话信号而设计的。



#### 1.1.4 应用层

应用层负责处理应用程序的逻辑。数据链路层、网络层、传输层负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核中实现，如图1-1所示。而应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询、和网络管理等。如果应用层也在内核当中实现，则会使内核变得非常庞大。当然，也有少数服务器程序是在内核当中实现的，这样代码无须在用户空间和内核空间来回切换（主要是数据的复制），极大地提高了工作效率。不过这种代码实现起来比较复杂，不够灵活，不便于移植。

ping是应用程序，使用icmp协议检测网络连接，是调试i网络环境的必备工具。

telnet协议是一种远程登录协议，它使我们能在本地完成远程任务。

OSPF（open shortest patch first 开发最短路径优先）协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。

DNS协议提供机器域名到IP地址的转换。





### 1.2 封装

Encapsulation

![image-20210712111317662](Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20210712111317662.png)	

应用程序数据在发送到物理网络之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。

![image-20210712111742563](Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20210712111742563.png)	

TCP message segment

![image-20210712112320015](Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20210712112320015.png)	



当发送端应用程序使用send函数向一个TCP连接写入数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。

经过udp封装后的数据称为UDP数据报。UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用程序数据保存副本，因为它提供的服务是不可靠的。当一个UDP数据被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据拷贝到UDP内核发送缓冲区当中。	

经过IP封装后的数据称为数据报。IP数据报也包括头部信息和数据部分，其中数据部分就是一个TCP、UDP或者ICMP。

经过数据链路层封装的数据称为帧。传输媒介不同	，帧的类型也不同。帧的最大传输单元（Max transmit Unit, MTU）是1500字节。正因为如此,过长的IP数据报可能需要被分片传输。

![image-20210712134021505](Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20210712134021505.png)

**帧才是最终在物理网络上传送的字节序列。**



### 1.3 分用

![image-20210712134406561](Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20210712134406561.png)	

因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供某个字段来区分它们。以太网帧为例，它使用两字节的类型字段来标识上层协议。如果主机接收到的以太网帧类型字段的值为0x800 ，则帧的数据部分为IP数据报，以太网驱动程序就将帧交付给ARP模块。

TCP报文段和UDP数据报则通过其头部中的16位端口号字段来区分上层应用程序。

帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务。这样，在顶层目标服务来看，封装和分用似乎没发生过。



### 1.4 测试网络

