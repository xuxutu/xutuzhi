## 第三章 目标文件里有什么

### 3.3 测试程序代码

![image-20210816132605278](linker.assets/image-20210816132605278.png)	

1.objdump -h 打印各个段的基本信息

![image-20210816125605044](linker.assets/image-20210816125605044.png)	



CONTENTS表示该段在文件中存在



2.size查看

![](linker.assets/image-20210816131038549.png)	



#### 3.3.1 代码段

![image-20210816131539540](linker.assets/image-20210816131539540.png)	

![image-20210816131600124](linker.assets/image-20210816131600124.png)	



#### 3.3.2 数据段和只读数据段

![image-20210816132530927](linker.assets/image-20210816132530927.png)	

​	

```
0x54 = 84;
0x55 = 85
```

```
只读数据：
% =0x25
d  =0x64
\n =0x0A
\0 =0x00
```

“.rodta“段存放的时只读数据，一般是程序里面的**只读变量**（如**const**修饰的变量）和 **字符串常量**。

单独设.r**odata段有很多好处**，不光是在语义上支持了C++的const关键字，而且操作系统在加载的时后可以将“.rodata“段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性。另外在某些嵌入式平台下，有些存储区域是采只读存储器的，如ROM，这样将“.rotada”段放在该存储区域中，就可以保证访问存储器的正确性。

另外值得一提的是，有**时候编译器会把字符串常量放到“.data”段中.将.c改为.cpp可验证**
