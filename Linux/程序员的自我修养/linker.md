## 第三章 目标文件里有什么

![image-20210813172730781](linker.assets/image-20210813172730781.png)	

### 3.3 测试程序代码

![image-20210816132605278](linker.assets/image-20210816132605278.png)	

1.objdump -h 打印各个段的基本信息

![image-20210816125605044](linker.assets/image-20210816125605044.png)	



CONTENTS表示该段在文件中存在



2.size查看

![](linker.assets/image-20210816131038549.png)	



#### 3.3.1 代码段

![image-20210816131539540](linker.assets/image-20210816131539540.png)	

![image-20210816131600124](linker.assets/image-20210816131600124.png)	



#### 3.3.2 数据段和只读数据段

![image-20210816132530927](linker.assets/image-20210816132530927.png)	

​	

```
0x54 = 84;
0x55 = 85
```

```
只读数据：
% =0x25
d  =0x64
\n =0x0A
\0 =0x00
```

“.rodta“段存放的时只读数据，一般是程序里面的**只读变量**（如**const**修饰的变量）和 **字符串常量**。

单独设.r**odata段有很多好处**，不光是在语义上支持了C++的const关键字，而且操作系统在加载的时后可以将“.rodata“段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性。另外在某些嵌入式平台下，有些存储区域是采只读存储器的，如ROM，这样将“.rotada”段放在该存储区域中，就可以保证访问存储器的正确性。

另外值得一提的是，有**时候编译器会把字符串常量放到“.data”段中.将.c改为.cpp可验证**



#### 3.3.3 BSS段

.bss存放的是**未初始化**的**局部静态变量和全局变量**

有些编译器会将全局的为未始化变量存放在目标文件.bss段，有些则不存放，只是预留一个为定义的全局变量符号，等到最终链接成可执行文件的时候再在.bss段分配空间。

**注意下边全局的已初始化的变量的存放位值**

```
static int x1 = 0; .bss
static int x2 = 1; .data
```



#### 3.3.4 其他段

![image-20210817130225723](linker.assets/image-20210817130225723.png)	

1.我们可以自己插入一个段比如music，但是不能以.开头

2.一个ELF文件可以有几个相同段名的段，比如.text

3.一些保留的段是历史遗留问题造成的



#### 3.3.5 自定义段

![image-20210817135744565](linker.assets/image-20210817135744565.png)		



#### 3.3.6 代码指定段

![image-20210817135843697](linker.assets/image-20210817135843697.png)	



### 3.4 ELF文件结构描述

![image-20210817140558198](linker.assets/image-20210817140558198.png)	

ELF文件头描述了整个文件的基本属性,紧接着是ELF文件的各个段。其中ELF为文件中与段有关的最重要的结构是段表，该表描述了与ELF文件包含的所有段的信息。

#### 3.4.1 文件头

![image-20210817143719697](linker.assets/image-20210817143719697.png)	



ELF文件头结构及相关常数被定义在“/usr/include/elf.h”里。32位、64位的头部结构分别为Elf32_Ehdr、Elf64_Ehdr.



Elf32_Ehdr:

![image-20210817144755447](linker.assets/image-20210817144755447.png)	



##### 1)ELF魔数

用来标识ELF文件的平台属性

![image-20210817145925965](linker.assets/image-20210817145925965.png)	

前四个字节是标识码

```
0x7f= DEL
0x45= 'E'
0x4c= 'L'
0x46= 'F'
```

操作系统在加载可执行文件的时候会确认魔数是否会正确，如果不正确会拒绝加载

接下来一个字节标识类型

```
0x01 表示32位
0x02 表示64位
```

第6个字节表示字节序

```
0x01 小端
```

第7个字节表示主版本号

```
0x01
```

后边的9个字节未定义，为0

##### 2)e_type

表示ELF文件类型

![image-20210817160444471](linker.assets/image-20210817160444471.png)	

##### 3)机器类型

e_machine 表示该ELF文件的平台属性，

![image-20210817160856267](linker.assets/image-20210817160856267.png)	



#### 3.4.2 段表

段表（Section Header Table）保存段的基本属性的结构，它描述了ELF的各个段的信息。比如每个段的**段名**、段的**长度**、在文件中的**偏移**、**读写权限**及段的其他属性。段表在ELF中的位置由ELF文件头的**e_shoff**成员决定。、

真正的**段表结构**

![image-20210904164111826](linker.assets/image-20210904164111826.png)	

##### **段描述符**

![](linker.assets/image-20210904164730499.png)	



##### 段的类型

段的名字只在链接和编译过程中有意义，但它不能真正地表示段的类型。我们可以将一个数据段命名为“。text”，对于编译器和链接器来说，主要决定段的属性的是段的类型（sh_type）和段的标志位（sh_flags）。**段的类型**相关的常量以SHT开头：

![image-20210905140449669](linker.assets/image-20210905140449669.png)	

![image-20210905140510531](linker.assets/image-20210905140510531.png)	



##### 段的标志位

段的标志位表示该段在进程虚拟地址空间的属性，比如**是否可写**，是**否可执行**等。相关常量以SHF开头。

![](linker.assets/image-20210905140914046.png)	

系统保留段的属性

![image-20210905141038842](linker.assets/image-20210905141038842.png)	

![](linker.assets/image-20210905141229440.png)	

##### 段的链接信息

如果段的链接与符号相关的，比如重定位表、符号表等，那么sh_link和sh_info这两个成员所包含的意义如表3-11所示。对于其它类型的段，这两个成员没有意义。

![image-20210905141600490](linker.assets/image-20210905141600490.png)	



#### 3.4.3 重定位表

​	.rel.text段，它的类型为SHT_REL,也就是说它是一个重定位表（Relocation Table)。正如我们最开始所说的，链接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用位值。这些重定位的信息都记录在ELF文件的重定位表里面，对于每个须要重定位的代码段和数据段，都会有一个相应的重定位表。比如“。rel.text”就是针对.text段的重定位表，因为“.text”段中至少有一个绝对地址的引用，那就是对printf函数的调用；而.data段则没有绝对地址的引用，它至包含了几个常量。

​	一个重定位表同时也是ELF的一个段，那么这个段的类型（sh_type）就是“SHL_REL类型的，它的sh_link表示符号表的下标，它的“sh_info”表示它作用于哪个段。比如“.rel.text”作用于“.text”段。



#### 3.4.4 字符串表

ELF文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往都是不确定的，所以用固定的结构表示它很困难。一种常见的做法时把字符串集中起来做一个表，然后使用字符串在表中的偏移来引用字符串。

![image-20210905144717099](linker.assets/image-20210905144717099.png)	

通过这种方法，在ELF文件中引用字符串只需要给出一个字符串下标即可，不用考虑字符串长度问题。一般字符串表在ELF文件中以段的形式保存，常见的段名为“.strlab”或".shstrtab"。这两个字符串表为**字符串表**和**段字符传表**。顾名思义，字符串表用来保存普通的字符串，比如符号的名字；段字符串表用来保存段表中用到的字符串，最常见的就是段名（sh_name）。



**e_shstrbndx**. 段表字符串表本身也是ELF文件中的一个普通的段，知道它的名字往往叫做“,shstrtab”.e_shstrbndx表示shstrtab在段表中的下标

**因此通过文件头我们可以获取字符串表的信息**



### 3.5 链接的接口--符号

**链接过程的本质**就是**把多个不同的目标文件之间相互“粘”到一起**，或者像玩具积木一样，可以拼接成一个整体。为了使不同目标文件之间能够相互粘合，这些目标文件之间必须有固定的规则才行，就像积木模块必须有凹凸部分才能够拼合。在链接中，**目标文件相互拼合**实际上是**目标文件对地址的引用**，即对**函数和变量**的地址的引用。比如目标文件B要用到了目标文件A中的函数“foo”,那么我们就称目标文件A**定义**了函数“foo”，称目标文件B**引用**了目标文件A中的函数“foo”。这两个概念同样适用于**变量**。每个函数和变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量中统称为**符号**，函数名和变量名就是**符号名**。

我们可以将符号看作是链接中的粘合剂整个链接过程正是基于符号才能够正确完成。**链接过程中很关键的一部分就是符号的管理**，每一个目标文件都会有一个相应的**符号表**，这个表里记录了目标文件所用到的所有符号。每个定义的符号都有一个对应的值，叫做**符号值**，对于**变量和函数**来说，**符号值就是**它们的**地址**。除了函数和变量之外，还存在几种不常用到的符号。我们将符号表中的符号进行分类，它们有可能是下面类型的一种：

1.定义在目标文件的全局符号，可以被其他目标文件引用。

2.在本目标文件引用的全局符号，却没有定义在本目标文件中，这一般叫作外部符号，也就是符号引用。

3.段名，这种符号往往由编译器产生，它的值就是该段的起始地址。

4.局部符号，这类符号只在编译单元内部可见。调试器可以通过这些符号分析程序的核心转储文件。这些局部符号对于链接过程没有作用，链接器往往也忽略它们。

5.行号信息，即目标文件中指令与源代码中代码行的对应关系，它们是可选的。

对于我们来说，最值的关注的就是全局符号，因为链接过程只关注全局符号的相互“粘合”，局部符号、段名、行号都是次要的，它们对于其他目标文件来说是“不可见”的，在链接过程中是无关紧要的。

查看符号表：

![image-20210911172103704](linker.assets/image-20210911172103704.png)	



#### 3.5.1 ELF符号表结构

