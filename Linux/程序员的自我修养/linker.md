## 第三章 目标文件里有什么

![image-20210813172730781](linker.assets/image-20210813172730781.png)	

### 3.3 测试程序代码

![image-20210816132605278](linker.assets/image-20210816132605278.png)	

1.objdump -h 打印各个段的基本信息

![image-20210816125605044](linker.assets/image-20210816125605044.png)	



CONTENTS表示该段在文件中存在



2.size查看

![](linker.assets/image-20210816131038549.png)	



#### 3.3.1 代码段

![image-20210816131539540](linker.assets/image-20210816131539540.png)	

![image-20210816131600124](linker.assets/image-20210816131600124.png)	



#### 3.3.2 数据段和只读数据段

![image-20210816132530927](linker.assets/image-20210816132530927.png)	

​	

```
0x54 = 84;
0x55 = 85
```

```
只读数据：
% =0x25
d  =0x64
\n =0x0A
\0 =0x00
```

“.rodta“段存放的时只读数据，一般是程序里面的**只读变量**（如**const**修饰的变量）和 **字符串常量**。

单独设.r**odata段有很多好处**，不光是在语义上支持了C++的const关键字，而且操作系统在加载的时后可以将“.rodata“段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性。另外在某些嵌入式平台下，有些存储区域是采只读存储器的，如ROM，这样将“.rotada”段放在该存储区域中，就可以保证访问存储器的正确性。

另外值得一提的是，有**时候编译器会把字符串常量放到“.data”段中.将.c改为.cpp可验证**



#### 3.3.3 BSS段

.bss存放的是**未初始化**的**局部静态变量和全局变量**

有些编译器会将全局的为未始化变量存放在目标文件.bss段，有些则不存放，只是预留一个为定义的全局变量符号，等到最终链接成可执行文件的时候再在.bss段分配空间。

**注意下边全局的已初始化的变量的存放位值**

```
static int x1 = 0; .bss
static int x2 = 1; .data
```



#### 3.3.4 其他段

![image-20210817130225723](linker.assets/image-20210817130225723.png)	

1.我们可以自己插入一个段比如music，但是不能以.开头

2.一个ELF文件可以有几个相同段名的段，比如.text

3.一些保留的段是历史遗留问题造成的



#### 3.3.5 自定义段

![image-20210817135744565](linker.assets/image-20210817135744565.png)		



#### 3.3.6 代码指定段

![image-20210817135843697](linker.assets/image-20210817135843697.png)	



### 3.4 ELF文件结构描述

![image-20210817140558198](linker.assets/image-20210817140558198.png)	

ELF文件头描述了整个文件的基本属性,紧接着是ELF文件的各个段。其中ELF为文件中与段有关的最重要的结构是段表，该表描述了与ELF文件包含的所有段的信息。

#### 3.4.1 文件头

![image-20210817143719697](linker.assets/image-20210817143719697.png)	



ELF文件头结构及相关常数被定义在“/usr/include/elf.h”里。32位、64位的头部结构分别为Elf32_Ehdr、Elf64_Ehdr.



Elf32_Ehdr:

![image-20210817144755447](linker.assets/image-20210817144755447.png)	



##### 1)ELF魔数

用来标识ELF文件的平台属性

![image-20210817145925965](linker.assets/image-20210817145925965.png)	

前四个字节是标识码

```
0x7f= DEL
0x45= 'E'
0x4c= 'L'
0x46= 'F'
```

操作系统在加载可执行文件的时候会确认魔数是否会正确，如果不正确会拒绝加载

接下来一个字节标识类型

```
0x01 表示32位
0x02 表示64位
```

第6个字节表示字节序

```
0x01 小端
```

第7个字节表示主版本号

```
0x01
```

后边的9个字节未定义，为0

##### 2)e_type

表示ELF文件类型

![image-20210817160444471](linker.assets/image-20210817160444471.png)	

##### 3)机器类型

e_machine 表示该ELF文件的平台属性，

![image-20210817160856267](linker.assets/image-20210817160856267.png)	



#### 3.4.2 段表

段表（Section Header Table）保存段的基本属性的结构，它描述了ELF的各个段的信息。比如每个段的**段名**、段的**长度**、在文件中的**偏移**、**读写权限**及段的其他属性。段表在ELF中的位置由ELF文件头的**e_shoff**成员决定。、

真正的**段表结构**

![image-20210904164111826](linker.assets/image-20210904164111826.png)	

##### **段描述符**

![](linker.assets/image-20210904164730499.png)	



##### 段的类型

段的名字只在链接和编译过程中有意义，但它不能真正地表示段的类型。我们可以将一个数据段命名为“。text”，对于编译器和链接器来说，主要决定段的属性的是段的类型（sh_type）和段的标志位（sh_flags）。**段的类型**相关的常量以SHT开头：

![image-20210905140449669](linker.assets/image-20210905140449669.png)	

![image-20210905140510531](linker.assets/image-20210905140510531.png)	



##### 段的标志位

段的标志位表示该段在进程虚拟地址空间的属性，比如**是否可写**，是**否可执行**等。相关常量以SHF开头。

![](linker.assets/image-20210905140914046.png)	

系统保留段的属性

![image-20210905141038842](linker.assets/image-20210905141038842.png)	

![](linker.assets/image-20210905141229440.png)	

##### 段的链接信息

如果段的链接与符号相关的，比如重定位表、符号表等，那么sh_link和sh_info这两个成员所包含的意义如表3-11所示。对于其它类型的段，这两个成员没有意义。

![image-20210905141600490](linker.assets/image-20210905141600490.png)	



#### 3.4.3 重定位表

​	.rel.text段，它的类型为SHT_REL,也就是说它是一个重定位表（Relocation Table)。正如我们最开始所说的，链接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用位值。这些重定位的信息都记录在ELF文件的重定位表里面，对于每个须要重定位的代码段和数据段，都会有一个相应的重定位表。比如“。rel.text”就是针对.text段的重定位表，因为“.text”段中至少有一个绝对地址的引用，那就是对printf函数的调用；而.data段则没有绝对地址的引用，它至包含了几个常量。

​	一个重定位表同时也是ELF的一个段，那么这个段的类型（sh_type）就是“SHL_REL类型的，它的sh_link表示符号表的下标，它的“sh_info”表示它作用于哪个段。比如“.rel.text”作用于“.text”段。



#### 3.4.4 字符串表

ELF文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往都是不确定的，所以用固定的结构表示它很困难。一种常见的做法时把字符串集中起来做一个表，然后使用字符串在表中的偏移来引用字符串。

![image-20210905144717099](linker.assets/image-20210905144717099.png)	

通过这种方法，在ELF文件中引用字符串只需要给出一个字符串下标即可，不用考虑字符串长度问题。一般字符串表在ELF文件中以段的形式保存，常见的段名为“.strlab”或".shstrtab"。这两个字符串表为**字符串表**和**段字符传表**。顾名思义，字符串表用来保存普通的字符串，比如符号的名字；段字符串表用来保存段表中用到的字符串，最常见的就是段名（sh_name）。



**e_shstrbndx**. 段表字符串表本身也是ELF文件中的一个普通的段，知道它的名字往往叫做“,shstrtab”.e_shstrbndx表示shstrtab在段表中的下标

