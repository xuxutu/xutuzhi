1. 全局變量以及函數的定義檢測更嚴格。
   1.1 如：int a;
	   int a=10;
       c能通過，c++報錯。
   1.2 参数类型增强，返回值检测增强，参数个数检测增强

2. 类型转换检测增强
   2.1 如：char *p=malloc（3）；
       c++不能通过。

3. struct 增强
   3.1 可以封装函数
   3.2 使用时无须struct
  
3. bool类型增强 
   3.1 c中没有bool

4. 三目运算符增强
   4.1 int a=30;
       int b=20;
       a>b?a:b=100 //c++,返回的是引用
       *(a>b?&a:&b)=100//c，返回的是常量


5.const的增強
   5.1 c中const的特性：
       5.1.1 修飾的全局變量，受到保護，不可以更改
       5.1.2 修飾的局部量，可以通過指針修改
       5.1.3 偽常量，不可以用來定義數組
   5.2 C++:
         被修饰的常量是基本类型:
         const int j=100;    int *p=const_cast<int*>(&j);    *p=200;    cout<<j<<endl;   输出为什么是100呢
         cout<<*p<<endl; //输出是改过的200
         5.2.1 编译器在优化代码时把cout<<j直接优化成cout<<100了，所以虽然p和&j的值一样，但cout<<j不再通过访问j的地址输出。（反汇编时也有看到直接把数字压栈push 100 ）
                 这是因为，const型在压栈时，是使用的直接的数，就有点像C的#define a 100
         const 变量修饰的是非基本类型:
         5.2.2 此时，程序编译时，不知道该用什么值替换再编译；所以，将会用一块内存地址替换，然后再编译 

         總結：const 修飾基本類型時，將立即數婭戰，並不分配內存。
