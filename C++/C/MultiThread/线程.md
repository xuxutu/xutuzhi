# 线程

## 1.线程id

gettid();



## 2.线程的创建

​	pthread_create();

​	线程的调度取决于调度器策略

## 3.线程的终止

### 3.1 三种方式

3.1.1  线程从启动例程返回，返回值就是线程的退出码

3.1.2 线程可以被统一进程中的其他线程取消

3.1.3 线程调用pthread_exit()函数

### 3.2 pthread_join

线程收尸，接收线程返回值

### 3.3 栈的清理

pthread_cleanup_push();

pthread_cleanup_pop();

成双出现，否则报语法错误。pop传真值时push才会被调用



## 4.线程的取消

### pthread_cancel

取消有两种状态：允许和不允许

允许取消又分为：异步取消、推迟取消

推迟取消是指推迟到cancel点才响应取消。

cancel点：POSIX定义的cancel点，都是可能引发阻塞的系统调用

### pthread_setcancelstate()

设置是否允许取消

### pthread_setcanceltype()

设置取消方式

### pthread_testcancel()

这个函数什么都不做，就是一个取消点

### pthread_detach()

已经detach的线程，对其join会报错



### pthread_once()

保证一个函数只执行一次

static pthread_once_t init_once = PTHREAD_ONCE_INIT;



## 5.线程的同步



### 5.1互斥锁类型

pthread_mutex_t;



### 5.2 互斥锁初始化

动态初始化：**pthread_mutex_init():**

静态初始化：static pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;



### 5.3 线程属性



### 5.4 互斥锁销毁

pthread_mutex_destroy();



### 5.5 互斥量的理解 

#### 5.5.1锁链案例

xutuzhi/C++/C/MultiThread/线程/src

**互斥量锁的是代码段，不是某个变量**。

#### 5.5.2 线程任务池案例

xutuzhi/C++/C/MultiThread/线程/src/primer_pool_busy.c

注意点：

1.临界区内的跳转目的地在临界区外，要解锁再跳出

2.//sleep 会造成不必要的调度颠簸，sched_yield();//出让调度器给别的线程，非常短的sleep

该程序用了**查询法**通信，处于忙等，耗用cpu高。

#### 5.5.3 线程令牌桶案例

xutuzhi/C++/C/MultiThread/线程/src/mytbf_mt

