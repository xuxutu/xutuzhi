# 线程

## 1.线程id

gettid();



## 2.线程的创建

​	pthread_create();

​	线程的调度取决于调度器策略

## 3.线程的终止

### 3.1 三种方式

3.1.1  线程从启动例程返回，返回值就是线程的退出码

3.1.2 线程可以被统一进程中的其他线程取消

3.1.3 线程调用pthread_exit()函数

### 3.2 pthread_join

线程收尸，接收线程返回值

### 3.3 栈的清理

pthread_cleanup_push();

pthread_cleanup_pop();

成双出现，否则报语法错误。pop传真值时push才会被调用



## 4.线程的取消

### pthread_cancel

取消有两种状态：允许和不允许

允许取消又分为：异步取消、推迟取消

推迟取消是指推迟到cancel点才响应取消。

cancel点：POSIX定义的cancel点，都是可能引发阻塞的系统调用

### pthread_setcancelstate()

设置是否允许取消

### pthread_setcanceltype()

设置取消方式

### pthread_testcancel()

这个函数什么都不做，就是一个取消点

### pthread_detach()

已经detach的线程，对其join会报错



### pthread_once()

保证一个函数只执行一次

static pthread_once_t init_once = PTHREAD_ONCE_INIT;



## 5.线程的同步



### 5.1互斥锁类型

pthread_mutex_t;



### 5.2 互斥锁初始化

动态初始化：**pthread_mutex_init():**

静态初始化：static pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;



### 5.3 线程属性



### 5.4 互斥锁销毁

pthread_mutex_destroy();



### 5.5 互斥量的理解 

#### 5.5.1锁链案例

xutuzhi/C++/C/MultiThread/线程/src

**互斥量锁的是代码段，不是某个变量**。

#### 5.5.2 线程任务池案例

xutuzhi/C++/C/MultiThread/线程/src/primer_pool_busy.c

注意点：

1.临界区内的跳转目的地在临界区外，要解锁再跳出

2.//sleep 会造成不必要的调度颠簸，sched_yield();//出让调度器给别的线程，非常短的sleep

该程序用了**查询法**通信，处于忙等，耗用cpu高。

###### 5.5.2.1.创建指定数量的线程

```
 66     pthread_t tid[THRNUM];
 67     int err, i;
 68 
 69 
 70     for(i = 0; i < THRNUM; i++)
 71     {
 72         err = pthread_create(tid + i, NULL, thr_primer, (void*)i);
 73         if(err)
 74         {
 75             fprintf(stderr, "ptherad_create error : %s\n", strerror(err));
 76             exit(1);
 77         }
 78     }
```

###### 5.5.2.2线程入口

```
 18 static void* thr_primer(void* p)
 19 {   
 20     int i, j, mark;
 21     
 22     while(1)
 23     {
 				//查询法判断num值
 24         pthread_mutex_lock(&mut_num);
 25         while(num == 0)
 26         {
 27             pthread_mutex_unlock(&mut_num);
 28             sched_yield();
 29             pthread_mutex_lock(&mut_num);
 30         }
 31 
 				//-1代表任务已经发完
 32         if(num == -1)
 33         {
 34             pthread_mutex_unlock(&mut_num);
 35             break;//临界区内的跳转目的地在临界区外，要解锁再跳出
 36         }
 37 
				//其他值代表获取到任务
 38         i = num;
 				//拿到任务后将num置0
 39         num = 0;
 40 
 41         pthread_mutex_unlock(&mut_num);
 42
 				//执行自己的任务
 43 
 44         for(j = 2; j < i/2; j++)
 45         {
 46             mark = 1;
 47             if((i % j) == 0)
 48             {   
 49                 mark = 0;
 50                 break;
 51             }
 52         }
 53 
 54         if(mark)
 55         {
 56             printf("[%d]%d is a primer\n", (int)p, i);
 57         }
 58     }
 59     pthread_exit(NULL);
 60 }

```



###### 5.5.2.3 上游负责分发任务

```
 80     for(i = LEFT; i <= RIGHT; i++)
 81     {
 82         pthread_mutex_lock(&mut_num);
 83         while(num != 0)
 84         {
 85             pthread_mutex_unlock(&mut_num);
 86             //sleep 会造成不必要的调度颠簸
 87             sched_yield();//出让调度器给别的线程，非常短的sleep
 88             pthread_mutex_lock(&mut_num);
 89         }
 90         num = i;
 91         pthread_mutex_unlock(&mut_num);
 92     }


```

###### 5.5.2.4main线程将状态值置-1

```
如果不判断，最后一个num值会出现没来得及被分配就直接置为-1的情况
95     pthread_mutex_lock(&mut_num);
 96     while(num != 0)
 97     {
 98         pthread_mutex_unlock(&mut_num);
 99         sched_yield();
100         pthread_mutex_lock(&mut_num);
101     }
102 
103     num = -1;
104     pthread_mutex_unlock(&mut_num);
```



#### 5.5.3 线程令牌桶案例

xutuzhi/C++/C/MultiThread/线程/src/mytbf_mt

##### 5.5.3.1.mytbf_init

```，见
1.pthread_once(&init_once, module_load); //只调一次module_load
2.申请内存并初始化，将指针添加到全局数组管理
```

##### 5.5.3.2.module_load

```
1.开启一个线程，为全局数组中所有的成员累积token
2.atexit(module_unload); //程序退出时卸载模块
```

##### 5.5.3.3.打开一个用来读取的文件，以指定速率进行读取

```
1.size = mytbf_fetchtoken(tbf, BUFSIZE); //获取token
2. while((len = read(sfd, buf, size)) < 0)	//读取
3. 如果token没用玩需要归还
	74         if(size - len > 0)
 	75             mytbf_returntoken(tbf, size - len);
```

##### 5.5.3.4.mytbf_fetchtoken

```
查询法判断token值是否为正，为正则返回最小值(期望值与已有值)
```

##### 5.5.3.5.mytbf_returntoken

```
还token
```

##### 5.5.3.6.mytbf_destroy 

```
187     struct mytbf_st* me = ptr;\
188 
189     pthread_mutex_lock(&mut_job);
190     job[me->pos] = NULL;//在全局数组中移除
191     pthread_mutex_unlock(&mut_job);
192 
193     pthread_mutex_destroy(&me->mut);//销毁锁
194     free(ptr);

```

##### 5.5.3.7.module_unload

```
 60     pthread_cancel(tid_alrm); //终止线程
 61     pthread_join(tid_alrm, NULL);//回收线程
 62 
 63     for(int i = 0; i < MYTBF_MAX; i++)
 64     {
 65         if(job[i] != NULL)
 66         {
 67             mytbf_destroy(job[i]);//释放内存
 68         }
 69     }
 70     pthread_mutex_destroy(&mut_job);//销毁锁

```



### 5.6 条件变量

**解锁等待**

**醒来第一步抢锁**

**如果锁被别人抢到，阻塞等着抢**

```
159         pthread_cond_wait(&me->cond, &me->mut);
160 /*
161         pthread_mutex_unlock(&me->mut);
162         sched_yield();
163         pthread_mutex_lock(&me->mut);
164 */

```

pthread_cond_t

pthread_cond_init()

pthread_cond_destroy()

pthread_cond_broadcast()

pthread_cond_signal()

pthread_cond_wait()

